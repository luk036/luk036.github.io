<!doctype html>
<html>
  <head>
    <title>
      âŒš Clock Skew Scheduling Under Process Variations
    </title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width"
    />
    <link rel="stylesheet" type="text/css" href="../katex/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/spaces.css" />
    <link rel="stylesheet" type="text/css" href="../css/slides.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-dark.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-light.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/bg-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>
  <body>
    <textarea id="source">
layout: true
class: typo, typo-selection

---

count: false
class: nord-dark, middle, center

# Yield-driven Clock Skew Scheduling Under Process Variations âŒš

@luk036 ğŸ‘¨ğŸ»â€ğŸ«

2025-05-06 ğŸ“…

---

## Abstract ğŸ“

The main topic of the lecture is clock skew scheduling under process variations. The lecture discusses various techniques and methods for optimizing clock skew to improve circuit performance or minimize timing failures. ğŸ”§

The lecture begins with an overview of the problem and background of clock skew scheduling. It then explains the concept of clock skew and the difference between zero skew and useful skew designs. The importance of meeting timing constraints, such as setup time and hold time, is discussed, along with the potential problems that can occur if these constraints are violated. ğŸ”„

The lecture presents various approaches to clock skew scheduling, such as traditional scheduling, yield-driven scheduling, and minimum cost-to-time ratio cycle formulation. It also examines various methods for finding the optimal clock period and the corresponding skew schedule, including linear programming and the use of the Bellman-Ford algorithm.

---

## Abstract (II) ğŸ“

The lecture goes on to discuss primitive solutions and their shortcomings, such as pre-allocating timing margins and using the Least Center Error Square (LCES) problem formulation. The lecture also introduces more advanced techniques such as slack maximization (EVEN) and prop-based methods that distribute slack along the most timing-critical cycle based on Gaussian models. The drawbacks of these methods are highlighted, particularly their assumptions about gate delay distributions. âš¡

Finally, statistical static timing analysis (SSTA) and the use of statistical methods to account for process variations are discussed. The concept of the most critical cycle is introduced, and the lecture provides experimental results to demonstrate the effectiveness of various clock skew scheduling techniques. ğŸ“ˆ

---

## Overview ğŸ—ºï¸

.pull-left[

-   Background ğŸ“š
-   Problem formulation â“
-   Traditional clock skew scheduling â³
-   Yield-driven clock skew scheduling ğŸ¯
-   Minimum cost-to-time ratio cycle formulation ğŸ”„

]
.pull-right[

![image](figs/dfm.svg)

]

---

## Sequential Logic

-   Local data path ğŸ”—

    ![image](lec05.files/fig01.svg)

---

## Sequential Logic (cont'd)

-   Graph

    ![image](lec05.files/fig02.svg)

---

## Clock Skew

.pull-left[

-   $T_\text{skew}(i,f) = t_i - t_f$, where â±ï¸
    -   $t_i$: clock signal delay at the initial register
    -   $t_f$: clock signal delay at the final register
-   We are not interested in the absolute time. Why? ğŸ¤”

]
.pull-right[

![image](lec05.files/fig04.svg)

]

---

## Timing Constraint

-   Setup time constraint â±ï¸
    $$T_\text{skew}(i,f) \le T_\text{CP} - D_{if} - T_\text{setup} = u_{if}$$
    While this constraint destroyed, cycle time violation (zero
    clocking) occurs.

-   Hold time constraint â³
    $$T_\text{skew}(i,f) \ge T_\text{hold} - d_{if} = l_{if}$$ While
    this constraint destroyed, race condition (double clocking) occurs.

---

## Zero Skew vs. Useful Skew

-   Zero skew ($t_i = t_f$) : Relatively easy to implement. âš–ï¸

-   Useful skew. Improve: ğŸ¯
    -   The performance of the circuit by permitting a higher maximum
        clock frequency, or
    -   The safety margins of the clock skew within the permissible
        ranges.

-   Max./min. path delays are got from static timing analysis
    (STA).

---

## Timing Constraint Graph

-   Create a graph by ğŸ“ˆ
    -   replacing the hold time constraint with a *h-edge* with cost
        $-(T_\text{hold} - d_{ij})$ from $\text{FF}_i$ to $\text{FF}_j$,
        and
    -   replacing the setup time constraint with an s-edge with cost
        $T_\text{CP} - D_{ij} - T_\text{setup}$ from $\text{FF}_j$ to
        $\text{FF}_i$.
-   Two sets of constraints stemming from clock skew definition: ğŸ”—
    -   The sum of skews for paths having the same starting and ending
        flip-flop to be the same;
    -   The sum of clock skews of all cycles to be zero

---

## Timing Constraint Graph (TCG)

![Example circuit](lec05.files/fig05.svg)

---

## Timing Constraint Graph (TCG)

.pull-left[

Assume $T_\text{setup} = T_\text{hold}$ = 0 â±ï¸

Clock period $T_\text{CP}$ is feasible if and only if current graph contains no
negative cost cycles.

]
.pull-right[

![TCG](lec05.files/tcgraph_bob.svg)

]

---

## Minimize Clock Period

- Linear programming (LP) formulation
  $$\begin{array}{ll}
      \text{minimize}   & {\color{darkorange}T_\text{CP} } \\
      \text{subject to} & l_{ij} \leq {\color{red}t_i} - {\color{red}t_j} \leq u_{ij}
  \end{array}$$
  where $\text{FF}_i$ and $\text{FF}_j$ are sequential adjacent

- The above constraint condition is so-called **system of difference
  constraints** (see Introduction to Algorithms, MIT): ğŸ”

- Note: easy to check if a feasible solution exists by detecting
  negative cycle using for example Bellman-Ford algorithm. ğŸ‘‰

---

## Basic Bellman-Ford Algorithm

```matlab
function BellmanFord(list vertices, list edges, vertex source)
    // Step 1: initialize graph
    for each vertex i in vertices:
        if i is source then u[i] := 0
        else u[i] := inf
        predecessor[i] := null

    // Step 2: relax edges repeatedly
    for i from 1 to size(vertices)-1:
        for each edge (i, j) with weight d in edges:
            if u[j] > u[i] + d[i,j]:
                u[j] := u[i] + d[i,j]
                predecessor[j] := i

    // Step 3: check for negative-weight cycles
    for each edge (i, j) with weight d in edges:
        if u[j] > u[i] + d[i,j]:
            error "Graph contains a negative-weight cycle"
return u[], predecessor[]
```

---

## Problems with Bellman-Ford Algorithm

-   The algorithm is originally used for finding the shortest paths. ğŸ”
-   Detecting negative cycle is just a side product of the algorithm. âš ï¸
-   The algorithm is simple, but... ğŸ”§
    -   detects negative cycle at the end only.
    -   has to compute all `d[i,j]`.
    -   Restart the initialization with `u[i] := inf`.
    -   requests the input graph must have a source node.

Various improvements have been proposed extensively.

---

## Minimize clock period (I)

-   Fast algorithm for solving the LP: âš¡
    -   Use binary search method for finding the minimum clock period.
    -   In each iteration, Bellman-Ford algorithm is called to detect if
        the timing constraint graph contains negative weighted edge
        cycle.
-   Note: Originally Bellman-Ford algorithm is used to find a
    shortest-path of a graph. ğŸ‘‰

---

## Minimize clock period (II)

-   When the optimal clock period is solved, the corresponding skew
    schedule is got simultaneously. â±ï¸

-   However, many skew values are on the bounds of feasible range. âš ï¸

    ![Timing uncertainty emerges under processvariations](lec05.files/fig07.png)

---

## Yield-driven Clock Skew Scheduling

-   When process variations increase more and more,
    timing-failure-induced yield loss becomes a significant problem. ğŸ”„

-   Yield-driven Clock Skew Scheduling becomes important. ğŸ¯

-   Primary goal of this scheduling is to minimize the yield loss
    instead of minimizing the clock period. ğŸ¯

---

## Timing Yield Definition

-   The circuit is called functionally correct if all the setup- and
    hold-time constraints are satisfied under a group of determinate
    process parameters. âœ…

-   Timing Yield = (functional correct times) / sample number \* 100% ğŸ“ˆ

---

## Primitive solution (1)

-   Pre-allocate timing margins (usually equivalent to maximum timing
    uncertainty) at both ends of the FSR's (Feasible Skew Region). âš™ï¸
    $$l_{ij}  \leq s_{ij} \leq u_{ij} \implies l_{ij} + \Delta d \leq s_{ij}  \leq u_{ij} - \Delta d$$

-   Then perform clock period optimization.

---

## Problems with this method

-   The maximum timing uncertainty is too pessimistic. Lose some
    performance; âš ï¸

-   $\Delta d$ is fixed; it does not consider data path delay
    differences between cycle edges. âš ï¸

---

## References (1) ğŸ“‘

-   "Clock skew optimization", IEEE Trans. Computers, 1990 ğŸ“š
-   "A graph-theoretic approach to clock skew optimization", ISCAS'94
-   "Cycle time and slack optimization for VLSI-chips", ICCAD'99 â³
-   "Clock scheduling and clocktree construction for high performance
    Asics", ICCAD'03 âš™ï¸
-   "ExtensiveSlackBalance: an Approach to Make Front-end Tools Aware of
    Clock Skew Scheduling", DAC'06 ğŸ”„

---

## Primitive solution (2)

-   Formulate as LCES (Least Center Error Square) problem ğŸ“
    -   A simple observation suggests that, to maximize slack, skew
        values should be chosen as close as possible to the middle
        points of their FSR's.

    $$l_{ij} + lm_k (u_{ij} - l_{ij}) \leq s_{ij}  \leq u_{ij} - um_k (u_{ij} - l_{ij})$$

    $$\begin{array}{ll}
      \text{minimize}   & \sum_k (0.5 - \min(lm_k, um_k) )^2 \\
      \text{subject to} & 0 \leq lm_k \leq 0.5 \\
      & 0 \leq um_k \leq 0.5
    \end{array}$$

---

## References (2) ğŸ“‘

-   Graph-based algorithm
    -   (J. L. Neves and E. G. Friedman, "Optimal Clock Skew Scheduling
        Tolerant to Process Variations", DAC'96)

-   Quadratic Programming method
    -   (I. S. Kourtev and E. G. Fredman, "Clock skew scheduling for improved reliability via quadratic programming", ICCAD'99)

Shortcoming: might reduce some slacks to be zero to minimum **total** CES.
This is not optimal for yield. âš ï¸

---

## Primitive solution (3)

-   Incremental Slack Distribution ğŸ”„
    -   (Xinjie Wei, Yici CAI and Xianlong Hong, "Clock skew scheduling under process variations", ISQED'06)

-   Advantage: check all skew constraints âœ…

-   Disadvantage: didn't take the path delay difference intoconsideration âš ï¸

---

## Minimum Mean Cycle Based

-   **Even**: solve the slack optimization problem using a minimum mean
    cycle formulation. âš–ï¸
-   **Prop**: distribute slack along the most timing-critical cycle
    proportional to path delays ğŸ“
-   **FP-Prop**: use sensitizable-critical-path search algorithm for
    clock skew scheduling. ğŸ”

---

## Slack Maximization (EVEN)

- Slack Maximization Scheduling ğŸ“ˆ
  $$\begin{array}{ll}
      \text{maximize}   & {\color{darkorange}\beta} \\
      \text{subject to} & {\color{red}t_j} - {\color{red}t_i} \leq \mu_{ij} - {\color{darkorange}\beta}
  \end{array}$$

- Equivalent to the so-called minimum mean cycle problem (MMC), where ğŸ”„
  $${\color{darkorange}\beta}^* = \frac{1}{|C|} \sum\limits_{(i,j)\in C} \mu_{ij}$$ $C$:
  critical cycle (first negative cycle)

- Can be solved efficiently by the above method. âš¡

---

## Even - iterative slack optimization

-   Identify the circuit's most timing-critical cycle, ğŸ”
-   Distribute the slack along the cycle,
-   Freeze the clock skews on the cycle, and ğŸ§Š
-   Repeat the process iteratively. ğŸ”„

---

## Identify the timing-critical cycle

.pull-left[

1.  Identify the circuit's most timing-critical cycle ğŸ”
2.  Solve the minimum mean-weight cycle problem by âš™ï¸
    -   Karp's algorithm
    -   A. Dasdan and R.K.Gupta, "Faster Maximum and Minimum Mean Cycle
        Algorithms for System-Performance", TCAD'98.

]
.pull-right[

![image](lec05.files/tcgraph2_bob.svg)

]

---

## Distribute the slack

.pull-left[

Distribute the slack evenly along the most timing-critical cycle.

![image](lec05.files/tcgraph2_bob.svg)

]
.pull-right[

![image](lec05.files/fig10.png)

]

---

## Freeze the clock skews (I)

.pull-left[

Replace the critical cycle with super vertex. ğŸ§Š

![image](lec05.files/tcgraph4_bob.svg)

]
.pull-right[

![image](lec05.files/fig13.png)

]

---

## Freeze the clock skews (II)

.pull-left[

To determine the optimal slacks and skews for the rest of the graph,
we replace the critical cycle with super vertex.

![image](lec05.files/tcgraph5_bob.svg)

]
.pull-right[

![image](lec05.files/fig13.png)

]

---

## Repeat the process (I)

.pull-left[

![image](lec05.files/tcgraph6_bob.svg)

]
.pull-right[

![image](lec05.files/fig15.png)

]

---

## Repeat the process (II)

.pull-left[

![image](lec05.files/tcgraph7_bob.svg)

]
.pull-right[

![image](lec05.files/fig15.png)

]

---

## Final result

.pull-left[

-   $\text{Skew}_{12}$ = 0.75 â±ï¸
-   $\text{Skew}_{23}$ = -0.25 â±ï¸
-   $\text{Skew}_{31}$ = -0.5 â±ï¸
-   $\text{Slack}_{12}$ = 1.75 ğŸ“ˆ
-   $\text{Slack}_{23}$ = 1.75 ğŸ“ˆ
-   $\text{Slack}_{31}$ = 1 ğŸ“ˆ

]
.pull-right[

![image](lec05.files/tcgraph8_bob.svg)

]

where $\text{Slack}_{ij} = T_\text{CP} - D_{ij} - T_\text{setup} - \text{Skew}_{ij}$

---

## Problems with Even

-   Assume all variances are the same. âš ï¸
-   However, the timing uncertainty of a long combinational path is
    usually larger than that of a shorter path. âš ï¸
-   Therefore, the even slack distribution along timing-critical cycles
    performed by **Even** is not optimal for yield if data path delays
    along the cycles are different. âš ï¸

---

## Prop-Based on Gaussian model (I)

-   Assuming there are $n$ gates with delay $N(\mu,\sigma^2)$ in a path,
    then this path delay is $N(n\mu,n\sigma^2)$
-   Distribute slack along the most timing-critical cycle, according to
    the square root of each edge's path delays (???). ğŸ“
-   To achieve this, update the weights of s-edges and h-edges: âš™ï¸
    $$\begin{array}{ll}
    T_\text{CP} - (D_{ij} + \alpha \sqrt{D_{ij} } \sigma) - T_\text{setup} \\
    -T_\text{hold} + (d_{ij} - \alpha \sqrt{d_{ij} } \sigma)
    \end{array}$$

    where $\alpha$ ensures a minimum timing margin for
    each timing constraint.

---

## Prop-Based on Gaussian model (II)

-   Given a specific clock period $T_\text{CP}$, we gradually increase $\alpha$ and
    use the Bellman-Ford algorithm to detect whether it is still feasible. ğŸ”
-   After finding the maximum $\alpha$, the edges along the most
    timing-critical cycle will have slacks equal to the pre-allocated
    timing margins. ğŸ¯
-   Many edges in a circuit have sufficiently large slack. Therefore, we
    can perform proportional slack distribution only for the most
    timing-critical cycle. Assign the rest of skews using **Even**. ğŸ”„

---

## Problems with Prop

-   Assume all gate delay has the same distribution. âš ï¸
-   Not justify using the square root of path delay for timing margin. âš ï¸

---

## FP-Prop (I)

![image](lec05.files/fig18.png)
False path

---

## FP-Prop (II)

-   If we do not consider false path, some non timing-critical cycles
    become timing-critical. Then, more slacks are distributed to these
    cycles, but the slacks in actually timing-critical cycles are not
    sufficient. As a result, the overall timing yield decreases. âš ï¸

---

## Problems with FP-Prop

-   Same problems as Prop âš ï¸

---

## Experimental Results ğŸ§ª

![image](lec05.files/fig20.png)

---

## Statistical Method

-   Setup time constraint

    $$T_\text{skew}(i,f) \le T_\text{CP} - \tilde{D}_{if} - T_\text{setup}$$

-   Hold time constraint

    $$T_\text{skew}(i,f) \ge T_\text{hold} - \tilde{d}_{if}$$

    where $\tilde{D}_{if} \text{ and } \tilde{d}_{if}$
    are random variable under process variations.

---

## Statistical TC Graph

![image](lec05.files/tcgraph9_bob.svg)

After SSTA, edge weight is represented as a pair of value (mean, variance).

---

## Most Critical Cycle

-   Traditional criteria: minimum mean cycle â³

    $$\min_{C \in \mathcal{C} } \frac{\sum_{(i,j)\in C} \mu_{ij} }{|C|}$$

-   New criteria: ğŸ†•

    $$\min_{C \in \mathcal{C} } \frac{\sum_{(i,j)\in C} \mu_{ij} }{\sum_{(i,j)\in C} \sigma_{ij} }$$

    (We show the correctness later)

---

## Slack Maximization (C-PROP)

-   Slack Maximization Scheduling ğŸ“ˆ
  $$\begin{array}{ll}
    \text{maximize} & {\color{darkorange}\beta} \\
    \text{subject to} & {\color{red}t_j} - {\color{red}t_i}\leq \mu_{ij} - \sigma_{ij} {\color{darkorange}\beta}
  \end{array}$$

-   Equivalent to the *minimum cost-to-time ratio cycle* problem (MMC), where: ğŸ”„
    -   ${\color{darkorange}\beta}^* = \frac{\sum_{(i,j)\in C} \mu_{ij} }{\sum_{(i,j)\in C} \sigma_{ij} }$
    -   $C$: critical cycle (first negative cycle)

---

## Whole flow

-   After determining the clock arrival time at each vertex in the most
    critical cycle, the cycle is replaced with a super vertex $v'$. ğŸ”„
-   In-edge $(u, v)$ from outside vertex $u$ to cycle member $v$ is
    replaced by an in-edge $(u, v')$ with weight mean
    $\mu(u, v) - T_v$. ğŸ”—
-   Out-edge $(v, u)$ is replaced by out-edge $(v', u)$ with
    weight mean $\mu(v, u) + T_v$. However, the variance of the edge
    weight is not changed. And parallel edges can be remained. ğŸ”—
-   Repeat the process iteratively until the graph is reduced to a
    single super vertex, or the edges number is zero. ğŸ”„

---

## Data structure

![image](lec05.files/hierachy_bob.svg)

Final $T_1 = T_1 + T_7 +T_9$

---

## Advantages of This Method

-   Fast algorithm exists for minimum cost-to-time ratio cycle problem.
-   Reduce to Even when all variances are equal. ğŸ”„
-   When a variance tends to zero, it makes sense that only minimal
    slack is assigned to this variable, and hence others can be assigned
    more.

---

## Results

![image](lec05.files/fig21.png)\

---

## Main Reference ğŸ“‘

-   Jeng-Liang Tsai, Dong Hyum Baik, Charlie Chung-Ping Chen, and Kewal
    K. Saluja, "Yield-Driven, False-Path-Aware Clock Skew Scheduling",
    IEEE Design & Test of Computers, May-June 2005 ğŸ“š

---

## General Formulation

$$\begin{array}{ll}
      \text{maximum}   & g(\beta) \\
      \text{subject to} & {\color{red}t_i} - {\color{red}t_j} \leq f_{ij}(\beta), \; \forall (i,j) \in E
    \end{array}$$

where $f_{ij}(\beta)$ a linear function that represents various problems defined above.

| Problem | $g(\beta)$ | $f_{ij}(\beta)$ (setup)                                 | $f_{ji}(\beta)$ (hold)                        |
| ------- | ------ | --------------------------------------------------- | ----------------------------------------- |
| Min CP | $-\beta$   | $\beta - D_{ij} - T_\text{s}$                       | $-T_\text{h} + d_{ij}$                 |
| EVEN    | $\beta$    | $T_\text{CP} - D_{ij} - T_\text{s} - \beta$         | $-T_\text{h} + d_{ij} - \beta$             |
| C-PROP  | $\beta$    | $T_\text{CP}-D_{ij}-T_\text{s} - \sigma_{ij} \beta$ | $-T_\text{h} + d_{ij} - \sigma_{ij} \beta$ |

---

## General Formulation (cont'd)

-   In fact, $g(\beta)$ and $f_{ij}(\beta)$ are not necessarily linear functions.
    Any monotonic decreasing function will do. ğŸ”
-   Theorem: if $g(\beta)$ and $f_{ij}(\beta)$ are *monotonic decreasing*
    functions for all $i$ and $j$, then there is a unique solution to the problem. prove later). ğŸ“
-   Question 1: Does this generalization have any application? â“
-   Question 2: What if $g(\beta)$ and $f_{ij}(\beta)$ are convex but not monotone? â“

---

## Non-Gaussian Distribution

.pull-left[

-   ~~65nm and below,~~ the path delay is likely to have a non-Gaussian distribution ğŸ”•:

    Note: central limit theorem does not apply here. Why? ğŸ‘‰
]

.pull-right[

![image](figs/non-gaussian.png)

]

---

## Timing Yield Maximization

-   Formulation:
    -   $\max\{\min\{\text{Pr}\{{\color{red}t_j} - {\color{red}t_i} \leq \tilde{W}_{ij} \}\}\}$
    -   is not exactly timing yield but reasonable.
    -   does not require correlation information among $\tilde{W}_{ij}$. Why?

-   It is equivalent to: ğŸ”„

  $$\begin{array}{ll}
    \text{maximum} & {\color{darkorange}\beta} \\
    \text{subject to} & {\color{red}t_i} - {\color{red}t_j} \le T_\text{CP} - F^{-1}_{ji}({\color{darkorange}\beta}) \\
      & {\color{red}t_j} - {\color{red}t_i} \le F^{-1}_{ij}(1 - {\color{darkorange}\beta})
  \end{array}$$
    where $F_{ij}(\cdot) \text{ is CDF of } \tilde{W}_{ij}$

-   Luckily, any CDF must be a monotonic increasing function. âœ…

---

## Statistical Interpretations of C-PROP

-   Reduce to C-PROP when $\tilde{W}_{ij}$ is Gaussian, or precisely ğŸ”„

    $$F_{ij}(x) = K((x - \mu_{ij})/\sigma_{ij})$$

-   EVEN: identical distribution up to shifting âš–ï¸

    $$F_{ij}(x) = H(x - \mu_{ij})$$

    Not necessarily worse than C-PROP

---

## Comparison

![image](lec05.files/fig23.png)

---

## Three Solving Methods in General

-   Binary search based ğŸ”
    -   Local convergence is slow.
-   Cycle based ğŸ”„
    -   Idea: if a solution is infeasible, there exists a negative cycle
        which can always be "zero-out" with minimum effort (proof of
        optimality)
-   Path based ğŸ›¤ï¸
    -   Idea: if a solution is feasible, there exists a (shortest) path
        from where we can always improve the solution.

---

## Parametric Shortest Path Algorithms

-   Lawler's algorithm (binary search) âš™ï¸
-   Howard's algorithm (based on cycle cancellation) ğŸ”„
-   Hybrid method ğŸ”€
-   Improved Howard's algorithm âš¡
-   Input: ğŸ“¥
    -   Interval [Î²min, Î²max] that includes Î²\*
    -   Tol: tolerance
    -   G(V, E): timing graph
-   Output: ğŸ“¤
    -   Optimal Î²* and its corresponding critical cycle C

---

## Lawler's Algorithm

.column-2.column-norule.font-sm.mb-xs[

```uml
@startuml
 while ((Î²max - Î²min) > tol)
    : Î² := (Î²min + Î²max) / 2;
    if (a neg. cycle C under Î² exists) then
       : Î²max := Î²;
    else
       : Î²min := Î²;
    endif
 endwhile
 : Î²* := Î²;
@enduml
```

![image](http://www.plantuml.com/plantuml/svg/JOuz3i8m38NtdEAD2GYGEXR1macgrcqjfKOYHYstnswMUl7mlRzrvao8KPTkmmMwi2GyeU-S0knQADe7eWESuRA46vhxJdb4x20qNT7_UWjwuIi3VSn46nSj2JgJxDeQvZMMfzLFkT0HMiS1oi1ZyBVwoE2AK-L_)

]

---

## Howard's Algorithm

.column-2.column-norule.font-sm.mb-xs[

```uml
@startuml
 : Î² := Î²max;
 while (a neg. cycle C under Î² exists)
    : find Î²' such that
      sum{(i,j) in C | fij(Î²')} = 0;
    : Î² := Î²';
 endwhile
 : Î²* := Î²;
@enduml
```

![image](http://www.plantuml.com/plantuml/svg/BOsn3W8X44Hxlc8wm1XZ3RdABo6mobuy2jcBPzH_TqMdUoypcG11c21BsgB1lVALu18QNGx8ZwnqmjeAtRH76tVfta0JSEPM81PzpHLIammFvUNfU3zxSDFnIukp4-lVc72C__7lr2fIA-FLVErkwFW1)

]

---

## Hybrid Method

.column-2.column-norule.font-sm.mb-xs[

```uml
@startuml
 while ((Î²max - Î²min) > tol)
    : Î² := (Î²min + Î²max) / 2;
    if (a neg. cycle C under Î² exists) then
       : find Î²' such that
         sum{(i,j) in C | fij(Î²')} = 0;
       : Î² := Î²';
       : Î²max := Î²;
    else
       : Î²min := Î²;
    endif
 endwhile
 : Î²* := Î²;
@enduml
```

![image](http://www.plantuml.com/plantuml/svg/JO_D2eD038JlFiKS17VxJu-AlVWaecjTqHMw4Irjtxt9Igcv1EQRJ9AvjRs1KZIK2uwWmJgD6sZiTGIk58GqXnA0FSIcSSOr2zGsK2MSkPzGFIiEAZ2vsZnuo2pMazUWrhZW3M6DTJLYIcBugMePbeGV1Ml3Izb3fy7B2hpPtYbAz0SvBja_9Pn4oLQHyqLSDTDxiuKSju6kjaqaRPRd8t7iLlu5)

]

---

## Improved Howard's Algorithm

.column-2.column-norule.font-sm.mb-xs[

```uml
@startuml
 : Î² := (Î²min + Î²max) / 2;
 while (no neg. cycle under Î²)
    : Î²min := Î²;
    : Î² := (Î²min + Î²max) / 2;
 endwhile
 while (a neg. cycle C under Î² exists)
    : find Î²' such that
      sum{(i,j) in C | fij(Î²')} = 0;
    : Î² := Î²';
 endwhile
 : Î²* := Î²;
@enduml
```

![image](http://www.plantuml.com/plantuml/svg/TOx13i8W44Jl_Ogv0MhKUAJfgLz208L6CB7RMAF-kniCnXxSsqnstem6GNUGb6B66fJChB33eMrm2_7i8VC5sP-si7VBSihENq6g0Pz6YN6Uschye_di2l3BDR_OleBXvpZIMFd7c1r8O9ni00L3nGVhz91nCoXmKOydFmwIX7gXmtwnXSIYdDtLP_0R)

]

---

## What can modern STA tools do today?

- Manually assign clock arrival times to registers (all zeros by default) âš™ï¸
- Grouping: Non-critical parts can be grouped as a single unit. ğŸ§©
  In other words, there is no need for full-chip optimization.
- Takes care of multi-cycle paths, slew rate, clock-gating, false paths etc. All we need are the reported **slacks**.
- Provide 3-sigma statistics for slacks/path delays (POCV). ğŸ“ˆ
- However, the full probability density function and correlation information are not available. âš ï¸

---

## Unimodality

- In statistics, a unimodal probability distribution or unimodal distribution is a probability distribution with a single peak.
- In continuous distributions, unimodality can be defined through the behavior of the cumulative distribution function (cdf). If the cdf is *convex* for $x < m$ and *concave* for $x > m$, then the distribution is unimodal, $m$ being the *mode*. ğŸ”
- Examples ğŸ“š
  - Normal distribution
  - Log-normal distribution
  - Log-logistic distribution
  - GEV distribution

---

## Quantile function

- The quantile function $z_p$ of a distribution is the inverse of the cumulative distribution function $\Phi^{-1}(p)$. ğŸ“
- Close-form expression for some unimodal distributions: ğŸ”¢
  - Normal: $\mu + \sigma\sqrt 2 \text{erf}^{-1}(2p - 1)$
  - Log-normal: $\exp\left( \mu + \sigma\sqrt 2 \text{erf}^{-1}(2p - 1)\right)$
  - Log-logistic: $\alpha\left( \frac{p}{1-p} \right)^{1/\beta}$

- For log-normal distribution:
  - mode: $\exp(\mu - \sigma^2)$
  - CDF at mode: $1/2 (1 + \text{erf}(-\sigma / \sqrt 2))$

---

## Setup- and Hold-time Constraints

- Let $T_\text{skew}(i,f) = {\color{red}t_i} - {\color{red}t_f}$, where â±ï¸
  - ${\color{red}t_i}$: clock signal delay at the initial register
  - ${\color{red}t_f}$: clock signal delay at the final register
  - Assume in zero-skew, i.e. $T_\text{skew}(i,f) = 0$,
      - the reported setup-time slack is $S_{if}$
      - the reported hold-time slack is $H_{if}$
- Then, in useful skew design:
    $$T_\text{skew}(i,f) \le  S_{if} \implies {\color{red}t_i} - {\color{red}t_f} \le S_{if}$$
    $$T_\text{skew}(i,f) \ge  -H_{if} \implies {\color{red}t_f} - {\color{red}t_i} \le H_{if} $$
- In principle, $H_{if} \text{ and } T_\text{CP} - S_{if}$ represent the minimum- and maximum-path delay, and should be always greater than zero.
- Let $D_{if} = T_\text{CP} - S_{if}$

---

## Yield-driven Optimization

- Max-Min Formulation: ğŸ¯
  - $\max\{\min\{ \text{Pr}\{{\color{red}t_j} - {\color{red}t_i} \le \tilde{W}_{ij} \}\}\}$,
  - No need for correlation information between $\tilde{W}_{ij}$.
  - Not exactly the timing yield objective but reasonable.
- Equivalent to: ğŸ”„
  $$\begin{array}{ll}
    \text{maximum} & {\color{darkorange}\beta} \\
    \text{subject to} & \text{Pr}\{{\color{red}t_i} - {\color{red}t_j} \le T_\text{CP} - \tilde{D}_{ij} \} \ge {\color{darkorange}\beta} \\
    & \text{Pr}\{{\color{red}t_j} - {\color{red}t_i} \le \tilde{H}_{ij} \} \ge {\color{darkorange}\beta}
  \end{array}$$
  or
  $$\begin{array}{ll}
    \text{maximum} & {\color{darkorange}\beta} \\
    \text{subject to} & {\color{red}t_i} - {\color{red}t_j} \le T_\text{CP} - \Phi^{-1}_{D_{ij}\ }({\color{darkorange}\beta}) \\
      & {\color{red}t_j} - {\color{red}t_i} \le \Phi^{-1}_{H_{ij}\ }(1 - {\color{darkorange}\beta})
  \end{array}$$

---

## Yield-driven Optimization (cont'd)

- In general, Lawler's algorithm (binary search) can be used. âš™ï¸
- Depending on the distribution, there are several other ways to solve problem. ğŸ”„

---

## Gaussian Model (Bell shape ğŸ””)

- Reduce to: ğŸ”„

$$\begin{array}{ll}
  \text{maximum} & {\color{darkorange}\beta} \\
  \text{subject to} & {\color{red}t_i} - {\color{red}t_j} \le T_\text{CP} - (\mu^D_{ij} + \sigma^D_{ij} {\color{blue}\sqrt 2\text{erf}^{-1}(2{\color{darkorange}\beta} - 1)} ) \\
    & {\color{red}t_j} - {\color{red}t_i} \le \mu^H_{ij} + \sigma^H_{ij} {\color{blue}\sqrt 2 \text{erf}^{-1}(2(1 - {\color{darkorange}\beta})-1)}
\end{array}$$

- Linearization. Since $\text{erf}^{-1}(\cdot)$ is anti-symmetric and monotonic, we have:

$$\begin{array}{ll}
  \text{maximum} & {\color{darkorange}\beta'} \\
  \text{subject to} & {\color{red}t_i} - {\color{red}t_j} \le T_\text{CP} - \mu^D_{ij} - \sigma^D_{ij} {\color{darkorange}\beta'} \\
    & {\color{red}t_j} - {\color{red}t_i} \le \mu^H_{ij} - \sigma^H_{ij} {\color{darkorange}\beta'}
\end{array}$$

- is equivalent to the minimum cost-to-time ratio cycle (linear).

- However, actual path delay distributions are non-Gaussian ğŸ”•.

---

## Log-normal Delay Model

- Reduce to:

$$\begin{array}{ll}
  \text{maximum} & {\color{darkorange}\beta} \\
  \text{subject to} & {\color{red}t_i} - {\color{red}t_j} \le T_\text{CP} - \exp(\mu^D_{ij} + \sigma^D_{ij} {\color{blue}\sqrt 2\text{erf}^{-1}(2{\color{darkorange}\beta} - 1)} ) \\
    & {\color{red}t_j} - {\color{red}t_i} \le \exp(\mu^H_{ij} + \sigma^H_{ij} {\color{blue}\sqrt 2 \text{erf}^{-1}(2(1 - {\color{darkorange}\beta})-1)})
\end{array}$$

- Since $\text{erf}^{-1}(\cdot)$ is anti-symmetric and monotonic, we have:

$$\begin{array}{ll}
  \text{maximum} & {\color{darkorange}\beta'} \\
  \text{subject to} & {\color{red}t_i} - {\color{red}t_j} \le T_\text{CP} - \exp(\mu^D_{ij} + \sigma^D_{ij} {\color{darkorange}\beta'}) \\
    & {\color{red}t_j} - {\color{red}t_i} \le \exp(\mu^H_{ij} - \sigma^H_{ij} {\color{darkorange}\beta'})
\end{array}$$

- Bypass evaluating error function. Non-linear and non-convex, but still can be solved efficiently by for example binary search on ${\color{darkorange}\beta'}$.

---

## Conclusion and Future Direction

- Asymmetric Delays

Path delays often exhibit asymmetric and heavy-tailed distributions, which cannot be accurately captured by the commonly used Gaussian model.

- GEV Distribution

The Generalized Extreme Value (GEV) distribution can better fit the actual delay distributions, with its flexible parameters allowing for a variety of skewness and tail behaviors.

---

count: false
class: nord-dark, middle, center

.pull-left[

# Q & A ğŸ¤

]
.pull-right[

![image](figs/questions-and-answers.svg)

]

---

Backup
------

```terminal
> pandoc -t beamer css.md beamer.yaml -o css.pdf
```
    </textarea>
    <script src="../js/remark.min.js"></script>
    <script src="../katex/katex.min.js" type="text/javascript"></script>
    <script
      src="../katex/contrib/auto-render.min.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      renderMathInElement(document.getElementById("source"), {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      });
      var slideshow = remark.create({
        ratio: "4:3", // çª—å£æ¯”ä¾‹
        // å¯é€‰ï¼šarta, ascetic, dark, default, far, github, googlecode, idea,
        // ir-black, magula, monokai, rainbow, solarized-dark, solarized-light,
        // sunburst, tomorrow, tomorrow-night-blue, tomorrow-night-bright,
        // tomorrow-night, tomorrow-night-eighties, vs, zenburn.
        highlightStyle: "tomorrow-night-eighties",
        highlightLines: true,
        countIncrementalSlides: false, // å¢é‡å†…å®¹æ˜¯å¦ç®—ä¸€é¡µ
        // slideNumberFormat: "", // è‹¥å°†æ­¤å‚æ•°è®¾ç½®ä¸º ""ï¼Œå°†ä¸æ˜¾ç¤ºé¡µç 
        navigation: {
          scroll: false, // æ˜¯å¦å…è®¸ä½¿ç”¨é¼ æ ‡æ»šè½®ç¿»é¡µ
          touch: true, // ï¼ˆå¦‚æœæ˜¯è§¦æ‘¸å±ï¼‰æ˜¯å¦å…è®¸ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
          click: false, // æ˜¯å¦å…è®¸é¼ æ ‡ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
        },
      });
    </script>
  </body>
</html>
