<!doctype html>
<html>
  <head>
    <title>Lecture 04c - Affine Arithmetic</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width"
    />
    <link rel="stylesheet" type="text/css" href="../katex/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/spaces.css" />
    <link rel="stylesheet" type="text/css" href="../css/slides.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-dark.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-light.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/bg-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>
  <body>
    <textarea id="source">

layout: true
class: typo, typo-selection

---

count: false
class: nord-dark, middle, center

# ğŸ“š  Lecture 04c - Affine Arithmetic

ğŸ‘¨ğŸ»â€ğŸ« @luk036

ğŸ“… 2024-10-16

---

class: center, middle

# ğŸ”º A Simple Example: Triangle Area Calculation

---

## ğŸ“ A Simple Area Problem

- Points $p$, $q$, and $r$ vary within 3 given rectangular regions
- **Q**: What are the upper/lower bounds of $\triangle pqr$ area?

![triangle](lec04.files/triangle.svg)


---

## ğŸ”³ Method 1: Corner-based Approach

- Calculate areas for all corner combinations
- **Issues**:
  - ğŸ§© Combinatorial explosion with many variables
  - âš ï¸ Worst-case may not occur at corners
  - â³ Computationally expensive for high dimensions

---

## ğŸ² Method 2: Monte Carlo Simulation

- Randomly sample points within variation ranges
- Calculate area for each sample
- **Pros**:
  - ğŸ“Š More accurate with more samples
- **Cons**:
  - â±ï¸ Time-consuming
  - No guarantees of finding true bounds

---

class: center, middle

# ğŸ”„ Interval vs. Affine Arithmetic

---

## Method 3: Interval Arithmetic (IA)

**Example Calculation**:
- px = [2, 3], py = [3, 4]
- qx = [-5, -4], qy = [-6, -5]
- rx = [6, 7], ry = [-5, -4]

**Area Calculation**:
- ((qx-px)(ry-py) - (qy-py)(rx-px))/2
- IA result: [33..61] (Actual: [36.5..56.5])

**Limitation**:
âŒ Cannot handle variable correlations

---

## â• Method 4: Affine Arithmetic (AA)

**Advantages**:
- âœ… Handles first-order correlations
- ğŸ¯ More accurate than IA (e.g., [35..57] in example)
- âš¡ Faster than Monte Carlo for small variations

**Implementation**:
- Public library: `libaffa.a`/YALAA
- Supports: +, -, *, /, sin(), cos(), pow(), etc.

---

## ğŸ”Œ Analog Circuit Example

**Unit Gain Bandwidth**:

`GBW = sqrt(A*Kp*Ib*(W2/L2)/(2*pi*Cc)`
where parameters have manufacturing variations

---

## ğŸ’» Enabling Technologies

**C++ Template Metaprogramming**:
```cpp
template <typename Tp>
Tp area(const Tp& px, const Tp& qx, const Tp& rx,
        const Tp& py, const Tp& qy, const Tp& ry) {
    return ((qx-px)*(ry-py) - (qy-py)*(rx-px)) / 2;
}
```
- Same code works for both `double` and `AAF` types
- Enables code reuse with minimal modifications

---

## ğŸ› ï¸ Applications of AA

- ğŸ›ï¸ Analog Circuit Sizing
- â±ï¸ Worst-Case Timing Analysis
- ğŸ“Š Statistical Static Timing Analysis
- ğŸ”Œ Parameter Variation Interconnect Modeling [CMU02]
- â° Clock Skew Analysis
- ğŸ•°ï¸ Bounded Skew Clock Tree Synthesis

---

## âš ï¸ Limitations of AA

**Functional Limitations**:
- ğŸ”„ No iterative methods (no fixed point in AA)
- â— No multiplicative inverse (no LU decomposition)
- ğŸ”¢ No total ordering (can't sort)

**Mathematical Limitations**:
- ğŸ“‰ Only handles linear correlations
- âŒ Poor approximation of `abs(x)` near zero

âœ… Fortunately the ellipsoid method is one of the few algorithms that works with AA.
---

## ğŸ—ï¸ Circuit Sizing for Op Amp

**Methodology**:
1. Geometric Programming formulation
2. Min-max convex programming under PVT variations
3. Ellipsoid Method optimization

---

## ğŸ“š What is Affine Arithmetic?

**Affine Form**:
  $$\hat{x} = x_0 + x_1 \epsilon_1 + \ldots + x_n \epsilon_n$$
where:
- $\epsilon_i \in [-1, 1]$ (noise symbols)
- $x_0$: central value
- $x_i$: partial deviations

**Example Conversion**:
IA [3..4] â†’ $3.5 + 0.5 \epsilon_1$

---

## ğŸ“ Geometry of AA

.pull-left70[

-   Affine forms that share noise symbols are dependent:
    -   $\hat{x} = x_0 + x_1 \epsilon_1 + \ldots + x_n \epsilon_n$
    -   $\hat{y} = y_0 + y_1 \epsilon_1 + \ldots + y_m \epsilon_m$
-   The region containing (x, y) is:
    -   $Z = \{(x, y) : \epsilon_i \in [-1, 1]\}$
    -   This region is a centrally symmetric convex polygon called "zonotope".
]
.pull-right30[

![zonotope](lec04.files/zonotope.svg)

]

---

# Affine Arithmetic

How to find $\sup_{q \in {\mathbb{Q} } } f_j(x,q)$ efficiently?

-   $\sup_{q \in {\mathbb{Q} } } f_j(x,q)$ is in general difficult to obtain.
-   Provided that variations are small or nearly linear, we propose using Affine Arithmetic (AA) to solve this problem.
-   Features of AA:
    -   Handle correlation of variations by sharing *noise symbols*.
    -   Enabling technology: template and operator overloading features of C++.
    -   A C++ package "YALAA" is publicly available.

---

## ğŸ” AA for Worst Case Analysis

-   An uncertain quantity is represented in an affine form (AAF):
    $$\hat{a} = a_0 + a_1 \varepsilon_1 + a_2 \varepsilon_2 +
      \cdots +  a_k \varepsilon_k = a_0 + \sum_{i=1}^{k} a_i \varepsilon_i,$$
    where
    -   $\varepsilon_i \in [-1, 1]$ is called *noise symbol*.
-   Exact results for affine operations ($\hat{a}+\hat{b}$,
    $\hat{a}-\hat{b}$ and $\alpha \cdot \hat{a}$)
-   Results of non-affine operations (such as $\hat{a} \cdot \hat{b}$, $\hat{a}/\hat{b}$, $\max(\hat{a}, \hat{b}), \log(\hat{a})$) are *approximated* in an affine form.
-   AA has been applied to a wide range of applications recently when process variations are considered.

---

## âš™ï¸ AA for Optimization

In our robust GP problem:

AA is used in worst-case scenario analysis to determine the maximum and minimum values of a function subject to variations in its inputs.
First, represent every elements in $q$ in affine forms.
For each ellipsoid iteration, $f(x_c,q)$ is obtained by *approximating* $f(x_c,\hat{q})$ in an affine form:

$$\hat{f} = f_0 + f_1 \varepsilon_1 + f_2 \varepsilon_2 + \cdots +  f_k \varepsilon_k.$$

Then the maximum of $\hat{f}$ is determined by:

$$\varepsilon_j = \left\{ \begin{array}{ll}
              +1 & \qquad \text{if} \; f_j > 0 \\
              -1 & \qquad \text{if} \; f_j < 0
            \end{array}
  \right.   \quad j=1, \cdots, k.$$

---

.pull-left70[

![Optimization Process](lec04.files/pic4.png)

]

---

## ğŸ¯ Performance Specifications

.column-2.font-sm.mb-xs[

| Constraint       | Spec.         | Units         |
|------------------|---------------|---------------|
| Device Width     | â‰¥ 2.0         | Î¼m            |
| Device Length    | â‰¥ 1.0         | Î¼m            |
| Area             | minimize      | Î¼mÂ²           |
| Input CM Voltage | [0.45,0.55]   | Ã— VDD         |
| Output Range     | [0.1,0.9]     | Ã— VDD         |
| Gain             | â‰¥ 80          | dB            |
| Unity Gain Freq. | â‰¥ 50          | MHz           |
| Phase Margin     | â‰¥ 60          | degrees       |
| Slew Rate        | â‰¥ 50          | V/$\mu$s      |
| CMRR             | â‰¥ 75          | dB            |
| Neg. PSRR        | â‰¥ 80          | dB            |
| Power            | $\leq 3$      | mW            |
| Noise, Flicker   | $\leq 800$    | nV/Hz$^{0.5}$ |

]

---

## ğŸ“ˆ Open-Loop Gain Example

-   Open-loop gain $A_v$ can be approximated as a monomial function:

    $$A_v =  \frac{2 C_{ox} }{(\lambda_n + \lambda_p)^2} \sqrt{\mu_n \mu_p \frac{W_1 W_6}{L_1 L_6 I_1 I_6} }$$

    where $I_1$ and $I_6$ are monomial functions.

-   Corresponding C++ code fragment:

    ```cpp
    // Open Loop Gain
    monomial<aaf> OLG = 2*COX/square(LAMBDAN+LAMBDAP)*
         sqrt(KP*KN*W[1]/L[1]*W[6]/L[6]/I1/I6);
    ```

---

## ğŸ“Š Design Variable Results

.column-2.font-sm.mb-xs[

| Variable   | Units  | GGPLAB  | Our   | Robust |
| ---------- | ------ | ------- | ----- | ------ |
| $W_1$      | Î¼m     | 44.8    | 44.9  | 45.4   |
| $W_8$      | Î¼m     | 3.94    | 3.98  | 3.8    |
| $W_{10}$   | Î¼m     | 2.0     | 2.0   | 2.0    |
| $W_{13}$   | Î¼m     | 2.0     | 2.0   | 2.1    |
| $L_1$      | Î¼m     | 1.0     | 1.0   | 1.0    |
| $L_8$      | Î¼m     | 1.0     | 1.0   | 1.0    |
| $L_{10}$   | Î¼m     | 1.0     | 1.0   | 1.0    |
| $L_{13}$   | Î¼m     | 1.0     | 1.0   | 1.0    |
| $A$        | N/A    | 10.4    | 10.3  | 12.0   |
| $B$        | N/A    | 61.9    | 61.3  | 69.1   |
| $C_c$      | pF     | 1.0     | 1.0   | 1.0    |
| $I_{bias}$ | Î¼A     | 6.12    | 6.19  | 5.54   |

]

---

## ğŸ† Performance Comparison

.font-sm.mb-xs[

  | Performance (units)            | Spec.        | Std.         | Robust       |
  | ------------------------------ | ------------ | ------------ | ------------ |
  | Estimated Area ($\mu$m$^2$)    | minimize     | 5678.4       | 6119.2       |
  | Output Range (x $V_{DD}$)      | [0.1, 0.9]   | [0.07, 0.92] | [0.07, 0.92] |
  | Comm Inp Range (x $V_{DD}$)    | [0.45, 0.55] | [0.41, 0.59] | [0.39, 0.61] |
  | Gain (dB)                      | $\geq 80$    | 80           | [80.0, 81.1] |
  | Unity Gain Freq. (MHz)         | $\geq 50$    | 50           | [50.0, 53.1] |
  | Phase Margin (degree)          | $\geq 60$    | 86.5         | [86.1, 86.6] |
  | Slew Rate (V/$\mu$s)           | $\geq 50$    | 64           | [66.7, 66.7] |
  | CMRR (dB)                      | $\geq 75$    | 77.5         | [77.5, 78.6] |
  | Neg. PSRR (dB)                 | $\geq 80$    | 83.5         | [83.5, 84.6] |
  | Power (mW)                     | $\leq 3$     | 1.5          | [1.5, 1.5]   |
  | Noise, Flicker (nV/Hz$^{0.5}$) | $\leq 800$   | $600$        | [578, 616]   |

]

---

## ğŸ¯ Conclusions

- âš¡ Fast computation (<1 sec on 3GHz CPU)
- ğŸ›¡ï¸ Guaranteed worst-case performance
- ğŸ“ˆ Robust GP formulation handles variations
- ğŸ—ï¸ Ellipsoid method provides reliable solutions

---

## ğŸ’­ Final Comments

- â• AA excels for small/near-linear variations
- ğŸ§© Combines well with zonotope geometry
- âš ï¸ Not universal - incompatible with:
  - ğŸ”„ Iterative methods
  - â— Matrix inversions
- ğŸ”„ Best combined with other methods (Monte Carlo)

---

count: false
class: nord-dark, middle, center

.pull-left[

# ğŸ™‹ Q & A

]
.pull-right[

![image](figs/questions-and-answers.svg)

]

    </textarea>
    <script src="../js/remark.min.js"></script>
    <script src="../katex/katex.min.js" type="text/javascript"></script>
    <script
      src="../katex/contrib/auto-render.min.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      renderMathInElement(document.getElementById("source"), {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      });
      var slideshow = remark.create({
        ratio: "4:3", // çª—å£æ¯”ä¾‹
        // å¯é€‰ï¼šarta, ascetic, dark, default, far, github, googlecode, idea,
        // ir-black, magula, monokai, rainbow, solarized-dark, solarized-light,
        // sunburst, tomorrow, tomorrow-night-blue, tomorrow-night-bright,
        // tomorrow-night, tomorrow-night-eighties, vs, zenburn.
        highlightStyle: "tomorrow-night-eighties",
        highlightLines: true,
        countIncrementalSlides: false, // å¢é‡å†…å®¹æ˜¯å¦ç®—ä¸€é¡µ
        // slideNumberFormat: "", // è‹¥å°†æ­¤å‚æ•°è®¾ç½®ä¸º ""ï¼Œå°†ä¸æ˜¾ç¤ºé¡µç 
        navigation: {
          scroll: false, // æ˜¯å¦å…è®¸ä½¿ç”¨é¼ æ ‡æ»šè½®ç¿»é¡µ
          touch: true, // ï¼ˆå¦‚æœæ˜¯è§¦æ‘¸å±ï¼‰æ˜¯å¦å…è®¸ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
          click: false, // æ˜¯å¦å…è®¸é¼ æ ‡ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
        },
      });
    </script>
  </body>
</html>
