<!doctype html>
<html>
  <head>
    <title>Lecture 8 - Phase Shifting Mask</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width"
    />
    <link rel="stylesheet" type="text/css" href="../katex/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/spaces.css" />
    <link rel="stylesheet" type="text/css" href="../css/slides.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-dark.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-light.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/bg-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>
  <body>
    <textarea id="source">

layout: true
class: typo, typo-selection

---

count: false
class: nord-dark, middle, center

# Lecture 8: Phase Shifting Mask âš™ï¸

@luk036 ğŸ‘¨â€ğŸ’»

2025-05-31 ğŸ“…

---

## Overview ğŸ“‹âœ¨

.pull-left[

-   Background ğŸ›ï¸
-   What is Phase Shifting Mask? â“
-   Phase Conflict Graph âš–ï¸
-   Phase Assignment Problem ğŸ§©
    -   Greedy Approach ğŸ¤‘
    -   Planar Graph Approach ğŸ“Š

]
.pull-right[

![image](figs/dfm.svg)

]

---

## Background ğŸ›ï¸

.pull-left[

-   In the past, chips have continued to get smaller and smaller, and therefore consume less and less power. âš¡ğŸ“‰

-   However, we are rapidly approaching the end of the road ğŸ›‘ and optical lithography cannot take us to the next place we need to go. ğŸš§

]
.pull-right[

![image](lec09.media/image1.jpeg)

]

---

## Process of Lithography ğŸ–¨ï¸

.pull-left[

1.  Photo-resist coating (å…‰é˜»æ¶‚å±‚) ğŸ¨

2.  Illumination (å…‰ç…§) ğŸ’¡

3.  Exposure (æ›å…‰) ğŸ“¸

4.  Etching (èš€åˆ») âš’ï¸

5.  Impurities doping (æ‚è´¨æºæ‚) ğŸ§ª

6.  Metal connection ğŸ”—

]
.pull-right[

![image](lec09.media/image2.png)

]

---

## Sub-wavelength Lithography ğŸŒŠğŸ“

.pull-left[

-   Feature size is much smaller than the lithography wavelength
    -   45nm vs.Â 193nm ğŸ“

![image](lec09.media/image4.png)

]
.pull-right[

-   What you see in the mask/layout is **not** what you get on the chip: ğŸ˜±
    -   Features are distored ğŸŒ€
    -   Yields are declined ğŸ“‰

![image](lec09.media/image3.png)

]

---

![image](lec08.files/000.jpg)

---

## What is the impact of lithography in DFM? â“âš™ï¸

Lithography is an important aspect of DFM because it plays a critical role in defining the physical features of the IC. DFM techniques such as phase shifting mask and multiple patterning can help address manufacturing issues related to lithography. ğŸ› ï¸

One of the main impacts of lithography in DFM is that it can cause variations in the dimensions and shapes of the IC's features, which can negatively impact the performance and yield of the IC. This is because lithography is a complex process that involves the use of light to transfer a pattern from a mask to a wafer. Variations in the intensity, wavelength, and angle of the light can cause deviations in the dimensions and shapes of the features, which can lead to process-induced variation. ğŸ“‰ğŸ”

---

## What is the impact of lithography in DFM? âš™ï¸ğŸ“Š

.pull-left[

![image](lec08.files/247-c-a-s_branded.png)

]
.pull-right[

![image](lec08.files/506-c_branded.png)

]

---

## DFM Tool (Mentor Graphics) ğŸ› ï¸ğŸ’»

![image](lec08.files/001.jpg)

---

## Optical Proximity Correction (OPC) ğŸ”âœ¨

.pull-left[

OPC is a photolithography enhancement technique that is commonly used to compensate for image errors due to diffraction or process effects. It modifies the mask layout to improve the fidelity of the printed image on the wafer ğŸ–¨ï¸

]
.pull-right[

![image](lec08.files/Optical_proximity_correction.png)

]

---

## OPC + SRAF ğŸ› ï¸â•

![image](lec08.files/F18.png)

---

## OPC and PSM ğŸ”„âš™ï¸

.pull-left[

-   Results of OPC on PSM:
    -   A = original layout ğŸ…°ï¸
    -   B = uncorrected layout ğŸ…±ï¸
    -   C = after PSM and OPC Â©ï¸

]
.pull-right[

![image](lec08.files/003.jpg)

]

---

## Phase Shifting Mask âš™ï¸ğŸŒ“

![image](lec08.files/004.jpg)

---

## Phase Conflict Graph âš–ï¸ğŸ“Š

-   Edge between two features with separation of $\leq b$ (dark field) âš«
-   Similar conflict graph for "bright field". âšª
-   Construction method: plane sweeping method + dynamic priority search tree ğŸŒ³

![image](lec08.files/005.jpg)

---

## Phase Assignment Problem ğŸ§©ğŸ¨

.pull-left[

-   Instance: Graph $G = (V, E)$ ğŸ“Š
-   Solution: A color assignment $c: V \to [1..k]$ (here $k=2$) ğŸ¨
-   Goal: Minimize the weights of the monochromatic edges.
    (Question: How can we model the weights?) âš–ï¸

]
.pull-right[

![image](lec08.files/006.jpg)

]

---

## Phase Assignment Problem ğŸ§©

-   In general, the problem is NP-hard. ğŸ¤¯
-   It is solvable in polynomial time for planar graphs with $k=2$, since the problem is equivalent to the T-join problem in the dual graph \[Hadlock75\]. â±ï¸
-   For planar graphs with $k=2$, the problem can be solved approximately in the ratio of two using the primal-dual method. 2ï¸âƒ£

---

## Overview of Greedy Algorithm ğŸ¤‘ğŸ“ˆ

-   Create a maximum weighted spanning tree (MST) of $G$ ğŸŒ³
    (can be found in LEDA package) ğŸ“¦
-   Assign colors to the nodes of the MST. ğŸ¨
-   Reinsert edges that do not conflict. ğŸ”„
-   Time complexity: $O(N \log N)$ â±ï¸
-   Can be applied to non-planar graphs. ğŸŒ

---

## Greedy Algorithm ğŸ¤‘

.pull-left[

-   Step 1: Construct a maximum spanning tree $T$ of $G$ (using e.g.Â Kruskal's algorithm, which is available in the LEDA package). ğŸ“¦

]
.pull-right[

![image](lec08.files/007.jpg)

]

---

## Greedy Algorithm (Cont'd) ğŸ”„

.pull-left[

-   Step 2: Assign colors to the nodes of $T$. ğŸ¨

]
.pull-right[

![image](lec08.files/008.jpg)

]

---

## Greedy Algorithm (Cont'd) ğŸ”„

.pull-left[

-   Step 3: Reinsert edges that do not conflict. â•

]
.pull-right[

![image](lec08.files/009.jpg)

]

---

![image](lec08.files/010.jpg)

---

## Other Approaches ğŸ”„ğŸ§ 

-   Reformulate the problem as a MAX-CUT problem. âœ‚ï¸
    Note that the MAX-CUT problem is approximatable within a factor of 1.1383
    using the "semi-definite programming" relaxation technique \[Goemans and Williamson 93\]. ğŸ“

-   Planar graph approach: Convert $G$ to a planar graph by removing the minimal edges, and then apply the methods to the resulting planar graph. ğŸ“Š

ğŸ‘‰ Note: the optimal "planar sub-graph" problem is NP-hard. ğŸ¤¯

---

## Overview of Planar Graph Approach (Hadlock's algorithm)

1.  Decompose $G$ into its bi-connected components. ğŸ”¨
2.  For each biconnected component in $G'$,
    1.  Approximate $G'$ by a planar graph $P$ ğŸ”„
    2.  construct a planar embedding ğŸ—ï¸
    3.  construct a dual graph ${\color{blue}P^*}$ ğŸ”„
    4.  construct a complete graph $C(V, E)$, where ğŸ§©
        -   $V$ is a set of odd-degree vertices in ${\color{blue}P^*}$
        -   the weight of each edge is the shortest path of two vertices
    5.  find the **minimum perfect matching** solution. ğŸ”
        The matching edges are the conflict edges that have to be deleted.
3.  Reinsert the non-conflicting edges from $G$. ğŸ”™

---

## Hadlock's Algorithm ğŸ”

- Decompose into Components ğŸª“

  Break the original graph G into its bi-connected components G' using linear time algorithms (available in LEDA package)

- Approximate to Planar Graph ğŸï¸

  Convert each compoment G' to a planar graph P (NP-hard, typically using greedy algorithms in O(nÂ²) time)

- Process Each Component ğŸ”„

  For each component P: construct planar embedding, build dual graph P*, create complete graph of odd-degree vertices

- Find Minimum Perfect Matching ğŸ¤

  Identify conflict edges that must be deleted, then reinsert non-conflicting edges from G

---

## Planar Graph Approach ğŸï¸

-   Step 1: Decompose $G$ into its bi-connected components in
    linear time (available in the LEDA package).

  ![image](lec08.files/012.jpg)

---

## Planar Graph Approach ğŸï¸

.pull-left[

-   Step 2: Approximate $G'$ with a planar graph $P$
    -   It is NP-hard.
    -   The naive greedy algorithm takes $O(n^2)$ time.
    -   Any good suggestion?

]
.pull-right[

  ![image](lec08.files/011.jpg)

]

---

## Planar Graph Approach ğŸï¸

-   Step 3: For each component $P$, construct a planar embedding in linear time

  ![image](lec08.files/013.jpg)

ğŸ‘‰ Note: planar embedding may not be unique unless $P$ is tri-connected.

---

## Planar Graph Approach ğŸï¸

.pull-left[

-   Step 4: For each component P, construct its dual
    graph ${\color{blue}P^*}$ in linear time.

]
.pull-right[

![image](lec08.files/014.jpg)

]

---

## Planar Graph Approach ğŸï¸

.pull-left[

-   Step 5: Find the minimum weight perfect matching of ${\color{blue}P^*}$.
    -   Polynomial time solvable.
    -   Can be formulated as a network flow problem.

ğŸ‘‰ Note: complete graph vs. Voronoi graph

]
.pull-right[

![image](lec08.files/015.jpg)

]

---

## Planar Graph Approach ğŸï¸

.pull-left[

-   Step 6: reinsert the non-conflicting edges in $G$.

ğŸ‘‰ Note: practically we keep track of conflicting edges.

]
.pull-right[

![image](lec08.files/016.jpg)

]

---

count: false
class: nord-dark, middle, center

.pull-left[

# Q & A ğŸ¤

]
.pull-right[

![image](figs/questions-and-answers.svg)

]

    </textarea>
    <script src="../js/remark.min.js"></script>
    <script src="../katex/katex.min.js" type="text/javascript"></script>
    <script
      src="../katex/contrib/auto-render.min.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      renderMathInElement(document.getElementById("source"), {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      });
      var slideshow = remark.create({
        ratio: "4:3", // çª—å£æ¯”ä¾‹
        // å¯é€‰ï¼šarta, ascetic, dark, default, far, github, googlecode, idea,
        // ir-black, magula, monokai, rainbow, solarized-dark, solarized-light,
        // sunburst, tomorrow, tomorrow-night-blue, tomorrow-night-bright,
        // tomorrow-night, tomorrow-night-eighties, vs, zenburn.
        highlightStyle: "tomorrow-night-eighties",
        highlightLines: true,
        countIncrementalSlides: false, // å¢é‡å†…å®¹æ˜¯å¦ç®—ä¸€é¡µ
        // slideNumberFormat: "", // è‹¥å°†æ­¤å‚æ•°è®¾ç½®ä¸º ""ï¼Œå°†ä¸æ˜¾ç¤ºé¡µç 
        navigation: {
          scroll: false, // æ˜¯å¦å…è®¸ä½¿ç”¨é¼ æ ‡æ»šè½®ç¿»é¡µ
          touch: true, // ï¼ˆå¦‚æœæ˜¯è§¦æ‘¸å±ï¼‰æ˜¯å¦å…è®¸ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
          click: false, // æ˜¯å¦å…è®¸é¼ æ ‡ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
        },
      });
    </script>
  </body>
</html>
