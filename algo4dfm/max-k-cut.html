<!doctype html>
<html>
  <head>
    <title>ğŸ”ª MAX-k-CUT Problem</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width"
    />
    <link rel="stylesheet" type="text/css" href="../katex/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/spaces.css" />
    <link rel="stylesheet" type="text/css" href="../css/slides.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-dark.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-light.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/bg-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>
  <body>
    <textarea id="source">

layout: true
class: typo, typo-selection

---

count: false
class: nord-dark, middle, center

# MAX-k-CUT Problem: Foundations and Applications ğŸ¯

@luk036 ğŸ‘¨â€ğŸ’»

---

## Abstract ğŸ“

The MAX-k-CUT problem is a fundamental graph partitioning challenge in computational optimization. It involves dividing graph vertices into k distinct color groups to maximize the weight of edges connecting differently colored vertices.

This lecture explores the mathematical foundations, computational complexity, solution approaches, and practical applications of the MAX-k-CUT problem, with special focus on planar graph techniques and divide-and-conquer methods using SPQR-trees.

---

## MAX-$k$-CUT Problem ğŸ§©

- Also known as MINIMUM EDGE DELETION $k$-PARTITION (Garey and Johnson GT32) ğŸ”¹

- INSTANCE: Graph $G=(V,E)$ and a weight function $w: E \rightarrow \mathbb{N}$ ğŸ”¹

- SOLUTION: An $k$-partition, i.e., a color assignment $c: V \rightarrow \{1,2,...,k\}$ ğŸ”¹

- MEASURE: The sum of weights of edges with different colors. ğŸ”¹

- Bad News: APX-hard (meaning it cannot be approximated arbitrarily well in polynomial time unless P=NP). ğŸ˜Ÿ

---

## MAX-CUT Problem ($k$ = 2) âœ‚ï¸

- Approximable within 1.1383 (using Semidefinite Relaxation) \[Goemans and Williamson 93\]. âœ…

- Not approximable within 1.058 \[Hastad 97\]. âŒ

- Polynomial time solvable for planar graphs, since the problem is equivalent to the T-join problem in the dual graph \[Hadlock75\]. ğŸï¸

- Approximable within 9/4 for planar graphs (using primal-dual method) \[Goemans and Williamson 95\]. ğŸ”„

- Linear time solvable for bipartite graphs due to natural 2-coloring properties of bipartite graphs. âš–ï¸

- Linear time solvable for series-parallel graphs (using SPQR-tree decomposition techniques). ğŸ§©

---

## Real-World Applications ğŸŒ

- Multiple Patterning Lithography ğŸ¨

  In semiconductor manufacturing, MAX-k-CUT helps resolve conflicts in layout decomposition for advanced lithography processes.

- Network Design & Resource Allocation ğŸŒ

  Optimizes network partitioning and resource distribution in telecommunications and computing systems.

- Image Segmentation ğŸ–¼ï¸

  Partitions images into meaningful regions for computer vision applications and medical imaging analysis.

- Many Others ğŸ”

  e.g. Via minimization in Mutli-Chip Module (MCM)

---

## Overview of Planar Graph Approach (Hadlock's algorithm)

1.  Decompose $G$ into its bi-connected components. ğŸ”¨
2.  For each biconnected component in $G'$,
    1.  Approximate $G'$ by a planar graph $P$ ğŸ”„
    2.  construct a planar embedding ğŸ—ï¸
    3.  construct a dual graph ${\color{blue}P^*}$ ğŸ”„
    4.  construct a complete graph $C(V, E)$, where ğŸ§©
        -   $V$ is a set of odd-degree vertices in ${\color{blue}P^*}$
        -   the weight of each edge is the shortest path of two vertices
    5.  find the **minimum perfect matching** solution. ğŸ”
        The matching edges are the conflict edges that have to be deleted.
3.  Reinsert the non-conflicting edges from $G$. ğŸ”™

---

## Hadlock's Algorithm ğŸ”

- Decompose into Components ğŸª“

  Break the original graph G into its bi-connected components G' using linear time algorithms (available in LEDA package)

- Approximate to Planar Graph ğŸï¸

  Convert each compoment G' to a planar graph P (NP-hard, typically using greedy algorithms in O(nÂ²) time)

- Process Each Component ğŸ”„

  For each component P: construct planar embedding, build dual graph P*, create complete graph of odd-degree vertices

- Find Minimum Perfect Matching ğŸ¤

  Identify conflict edges that must be deleted, then reinsert non-conflicting edges from G

---

## Planar Graph Approach ğŸï¸

-   Step 1: Decompose $G$ into its bi-connected components in
    linear time (available in the LEDA package).

  ![image](lec08.files/012.jpg)

---

## Planar Graph Approach ğŸï¸

.pull-left[

-   Step 2: Approximate $G'$ with a planar graph $P$
    -   It is NP-hard.
    -   The naive greedy algorithm takes $O(n^2)$ time.
    -   Any good suggestion?

]
.pull-right[

  ![image](lec08.files/011.jpg)

]

---

## Planar Graph Approach ğŸï¸

-   Step 3: For each component $P$, construct a planar embedding in linear time

  ![image](lec08.files/013.jpg)

ğŸ‘‰ Note: planar embedding may not be unique unless $P$ is tri-connected.

---

## Planar Graph Approach ğŸï¸

.pull-left[

-   Step 4: For each component P, construct its dual
    graph ${\color{blue}P^*}$ in linear time.

]
.pull-right[

![image](lec08.files/014.jpg)

]

---

## Planar Graph Approach ğŸï¸

.pull-left[

-   Step 5: Find the minimum weight perfect matching of ${\color{blue}P^*}$.
    -   Polynomial time solvable.
    -   Can be formulated as a network flow problem.

ğŸ‘‰ Note: complete graph vs. Voronoi graph

]
.pull-right[

![image](lec08.files/015.jpg)

]

---

## Planar Graph Approach ğŸï¸

.pull-left[

-   Step 6: reinsert the non-conflicting edges in $G$.

ğŸ‘‰ Note: practically we keep track of conflicting edges.

]
.pull-right[

![image](lec08.files/016.jpg)

]

---

class: middle, center

# SPQR-Tree ğŸŒ³

---

## Connected Graph ğŸ”—

- Recall that a graph $G = (V, E)$ is a *connected* if every pair of vertices $u, v$ in $G$ is connected by a path.

- A graph can be divided into its connected components in linear time.

- Clearly, the color assignment problem can be solved independently
  for each connected component without affecting any QoR.

---

## Bi-connected Graph ğŸ”—

- A vertex is called a *cut-vertex* of a connected graph $G$ if removing it disconnects $G$.

- If no cut-vertex is found in $G$, then the graph is called a bi-connected graph.

- In the following example, $a$, $b$ and $c$ are cut-vertices.

  ![An example of a conflict graph with its bi-connected components. Vertices $a$, $b$, and $c$ are cut-vertices.](lec09.pics/biconnected.svg)

---

## Bi-connected Components $G'$ ğŸ”—

- A division of $G$ into its bi-connected components can be performed in linear time by using a simple depth-first search to identify cut-vertices.

- It can be easily shown that the color assignment problem can be solved
  for each bi-connected component separately without affecting any QoRÂ [@chiang_fast_2005]

- Question: Is it possible to further decompose the graph? â“

---

## Tri-connected Graph ğŸ”—

- If removing a pair of vertices will disconnect $G'$, the pair is called a *separation pair* of $G'$.

- If no separation pair can be found in $G'$, then it is called a *tri-connected graph*.

- In the following example, $(a,b)$, $(g,h)$, $(c,d)$, $(c,e)$ and $(c,f)$ are separation pairs.

  ![An example of a conflict graph and its tri-connected components. $\{a,b\}$, $\{c,d\}$, $\{c,e\}$, $\{c,f\}$ and $\{g,h\}$ are separation pairs.](lec09.pics/cutvertices.svg)

---

## Tri-connected Graph Division ğŸ—ï¸

  ![image](lec09.pics/triconnected.svg)

---

## SPQR-tree ğŸŒ³

  ![image](lec09.pics/spqr-tree.svg)

- A division of $G'$ into its tri-connected components can be performed by identifying the separation pairs in linear time with the help of SPQR-treeÂ [@gutwenger_linear_2001].

---

## SPQR-Tree Decomposition ğŸŒ³

Each node in the tree represents a skeleton (a simplified version of a component) classified into one of four types:

- Series (S) ğŸ”„

  Skeleton is a cycle graph, representing a chain of components connected in series

- Parallel (P) â¸ï¸

  Skeleton contains two vertices with multiple (â‰¥3) parallel edges between them

- Trivial (Q) ğŸ”˜

  Skeleton has two vertices with one real edge and one virtual edge

- Rigid (R) ğŸ—ï¸

  Skeleton is a tri-connected graph not falling into the above categories

---

class: middle, center

# Divide-and-Conquer Method ğŸª“

---

## Divide-and-Conquer Method ğŸª“

- Divide ğŸ”ª

  Decompose the conflict graph into its tri-connected components using SPQR-tree. This creates a hierarchical structure of simpler subproblems.

- Conquer ğŸ†

  Solve each tri-connected component in a bottom-up manner, calculating two possible solutions: separation vertices (s,t) of the same color and (s,t) of opposite colors.

- Combine ğŸ§©

  Merge the solutions in a top-down manner to construct a complete solution for the original graph, selecting optimal configurations at each step.

This approach efficiently handles different skeleton types (S, P, R) with specific strategies for each. The bottom-up phase computes optimal solutions for components, while the top-down phase ensures global consistency.

---

![image](lec09.media/image9.svg)

---

## S Type ğŸ”„

![image](lec09.media/image10.svg)

---

## P Type â¸ï¸

![image](lec09.media/image11.svg)

---

## R Type ğŸ—ï¸

![image](lec09.media/image12.svg)

---

## Top-down Merging ğŸ”

![image](lec09.media/image13.svg)

---

## Application to Double Patterning ğŸ­

.pull-left[

![image](lec09.media/image5.png)

]
.pull-right[

![image](lec09.pics/TBUF_X8_9.svg)

]

Unlike conventional optical lithography, which exposes the photoresist once under one mask, masks is exposed twice by splitting them into two, each with half its feature density.

---

## 45 nm SDFFRS_X2 Layer 11, 9 ğŸ”¬

![image](lec09.pics/sdffrs_x2_9_950.svg)

![image](lec09.pics/sdffrs_x2_11_950.svg)

---

## 45 nm Example ğŸ”

![image](lec09.pics/45nm.svg)

---

![image](lec09.media/image15.png)

: fft_all, 320K polygons

---

## Experimental Results

| \#poly | \#nodes/\#edges | w/ spqr | w/o spqr | time  | cost  |
| ------ | --------------- | ------- | -------- | ----- | ----- |
| 3631   | 31371/52060     | 13.29   | 38.25    | 65.3% | 4.58% |
| 9628   | 83733/138738    | 199.94  | 2706.12  | 92.6% | 2.19% |
| 18360  | 159691/265370   | 400.43  | 4635.14  | 91.4% | 1.18% |
| 31261  | 284957/477273   | 1914.54 | 9964.18  | 80.7% | 1.61% |
| 49833  | 438868/738759   | 3397.26 | 15300.9  | 77.8% | 1.76% |
| 75620  | 627423/1057794  | 3686.07 | 17643.9  | 79.1% | 2.50% |

: Experimental results of the runtime and cost reduction (with minimizing the number of stitches)

---

## Challenges for kâ‰¥3 ğŸš§

For kâ‰¥3, the MAX-k-CUT problem becomes significantly more challenging. It's not approximable within O(|E|) and remains NP-hard even for tri-partite graphs with k=3. Current approaches rely on heuristic algorithms such as using "pairwise coloring" techniques.

---

## Future Directions ğŸ”®

- Advanced Approximation ğŸ¯

  Developing better approximation algorithms for specific graph classes

- Hardware Acceleration âš¡

  Leveraging specialized hardware for graph algorithms

- Machine Learning Integration ğŸ¤–

  Using ML to guide heuristic choices in complex instances

Future research directions include developing specialized algorithms for industry-specific graph structures, exploring quantum computing approaches for combinatorial optimization, and creating hybrid methods that combine theoretical guarantees with practical performance.

---

count: false
class: nord-dark, middle, center

.pull-left[

# Q & A ğŸ¤

] .pull-right[

![image](figs/questions-and-answers.svg)

]
    </textarea>
    <script src="../js/remark.min.js"></script>
    <script src="../katex/katex.min.js" type="text/javascript"></script>
    <script
      src="../katex/contrib/auto-render.min.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      renderMathInElement(document.getElementById("source"), {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      });
      var slideshow = remark.create({
        ratio: "4:3", // çª—å£æ¯”ä¾‹
        // å¯é€‰ï¼šarta, ascetic, dark, default, far, github, googlecode, idea,
        // ir-black, magula, monokai, rainbow, solarized-dark, solarized-light,
        // sunburst, tomorrow, tomorrow-night-blue, tomorrow-night-bright,
        // tomorrow-night, tomorrow-night-eighties, vs, zenburn.
        highlightStyle: "tomorrow-night-eighties",
        highlightLines: true,
        countIncrementalSlides: false, // å¢é‡å†…å®¹æ˜¯å¦ç®—ä¸€é¡µ
        // slideNumberFormat: "", // è‹¥å°†æ­¤å‚æ•°è®¾ç½®ä¸º ""ï¼Œå°†ä¸æ˜¾ç¤ºé¡µç 
        navigation: {
          scroll: false, // æ˜¯å¦å…è®¸ä½¿ç”¨é¼ æ ‡æ»šè½®ç¿»é¡µ
          touch: true, // ï¼ˆå¦‚æœæ˜¯è§¦æ‘¸å±ï¼‰æ˜¯å¦å…è®¸ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
          click: false, // æ˜¯å¦å…è®¸é¼ æ ‡ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
        },
      });
    </script>
  </body>
</html>
