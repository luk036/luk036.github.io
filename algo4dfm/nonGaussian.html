<!DOCTYPE html>
<html>
  <head>
    <title>Clock Skew Scheduling for non-Gaussian Delay Models</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../katex/katex.min.css"/>
    <link rel="stylesheet" type="text/css" href="slides.css"/>
    <style type="text/css">
      /* Slideshow styles */
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    </style>
  </head>
  <body>
    <textarea id="source">

class: middle, center

# Clock Skew Scheduling for non-Gaussian Delay Models

Wai-Shing Luk

2018-10-18

---

## Agenda

- Review of CSS Problems

- General Formulation

- Yield-driven Clock Skew Scheduling

- Numerical Results

---

## Minimum Clock Period Problem

- Linear programming (LP) formulation
    $$\begin{array}{ll}
      \text{minimize}   & T_{\mathrm{CP}} \\
      \text{subject to} & l_{ij} \leq t_i - t_j \leq u_{ij}
    \end{array}$$
  where 
  - $FF_i$ and $FF_j$ are sequentially adjacent.
  - $u_{ij}$ = $T_\text{CP} - D_{ij} - T_\text{setup}$
  - $l_{ij}$ = $T_\text{hold} - d_{ij}$

- The above constraint condition is called *system of difference constraints* (see Introduction to Algorithms, MIT):
  - Key: easy to check if a feasible solution exists by detecting a negative cycle using the Bellman-Ford algorithm.

---

## Slack Maximization (EVEN)

- Slack Maximization Scheduling
    $$\begin{array}{ll}
      \text{maximum}   & \beta \\
      \text{subject to} & t_i - t_j \leq \mu_{ij} - \beta
    \end{array}$$
  (Note: $\mu_{ij}$ = $u_{ij}$, $\mu_{ji}$ = $l_{ij}$)

- Equivalent to the so-called *minimum mean cycle problem* (MMC), where:
  - $\beta^* = {\sum_{(i,j) \in C} \mu_{ij} \over |C| }$,
  - $C$: critical cycle (first negative cycle)

- Can be solved efficiently by parametric shortest path methods.

---

## Slack Maximization (C-PROP)

- Slack Maximization Scheduling
    $$\begin{array}{ll}
      \text{maximum}   & \beta \\
      \text{subject to} & t_i - t_j \leq \mu_{ij} - \sigma_{ij} \beta
    \end{array}$$

- Equivalent to the *minimum cost-to-time ratio problem* (MCR), where:
  - $t^* = {\sum_{(i,j) \in C} \mu_{ij} \over \sum_{(i,j) \in C} \sigma_{ij}}$,
  - $C$: critical cycle

---


## Timing Yield Maximization

- Formulation:
  - $\min\{\max\{ \text{Pr}\{t_i - t_j \leq \tilde{W}_{ij} \}\}\}$
  - Not exactly timing yield but reasonable.

- Equivalent to:

    $$\begin{array}{ll}
      \text{maximum}   & \beta \\
      \text{subject to} & t_i - t_j \leq F_{ij}^{-1}(1-\beta)
    \end{array}$$

   where $F_{ij}(\cdot)$_ is CDF of $\tilde{W}_{ij}$

- Luckily, any CDF must be a monotonic increasing function.
  Thus, $F_{ij}^{-1}(1-t)$ is a monotonic decreasing function.

---

## Statistical Interpretations of C-PROP

- Reduce to C-PROP when $\tilde{W}_{ij}$ is Gaussian, or precisely

    $$F_{ij}(x) = K((x - m_{ij})/s_{ij})$$

- EVEN: identical distribution up to shifting

    $$F_{ij}(x) = H(x - m_{ij})$$

  Not necessarily worse than C-PROP

---

## Comparison

![img](lec05.files/fig23.png)\

---

## Three Solving Methods in General

- Binary search based
  - Local convergence is slow.

- Cycle based
  - Idea: if a solution is infeasible, there exists a negative cycle which can always be "zero-out" with minimum effort (proof of optimality)

- Path based
  - Idea: if a solution is feasible, there exists a (shortest) path from which we can always improve the solution.

---

## Parametric Shortest Path Algorithms

- Lawler's algorithm (binary search)

- Howard's algorithm (cycle cancellation based)

- Hybrid method

- Improved Howard's algorithm

- Input:
  - Interval [tmin, tmax] that includes t*
  - Tol: tolerance
  - G(V, E): timing graph
- Output:
  - Optimal t* and its corresponding critical cycle C

---

## Lawler's Algorithm

.pull-left[
.small[
```uml
@startuml
 while ((tmax - tmin) > tol)
    : t := (tmin + tmax) / 2;
    if (a neg. cycle C under t exists) then
       : tmax := t;
    else
       : tmin := t;
    endif
 endwhile
 : t* := t;
@enduml
```
]
]
.pull-right[
![img](http://www.plantuml.com/plantuml/svg/JOuz3i8m38NtdEAD2GYGEXR1macgrcqjfKOYHYstnswMUl7mlRzrvao8KPTkmmMwi2GyeU-S0knQADe7eWESuRA46vhxJdb4x20qNT7_UWjwuIi3VSn46nSj2JgJxDeQvZMMfzLFkT0HMiS1oi1ZyBVwoE2AK-L_)
]


---

## Howard's Algorithm

.pull-left[
.small[
```uml
@startuml
 : t := tmax;
 while (a neg. cycle C under t exists)
    : find t' such that 
      sum{(i,j) in C | fij(t')} = 0;
    : t := t';
 endwhile
 : t* := t;
@enduml
```
]
]
.pull-right[
![img](http://www.plantuml.com/plantuml/svg/BOsn3W8X44Hxlc8wm1XZ3RdABo6mobuy2jcBPzH_TqMdUoypcG11c21BsgB1lVALu18QNGx8ZwnqmjeAtRH76tVfta0JSEPM81PzpHLIammFvUNfU3zxSDFnIukp4-lVc72C__7lr2fIA-FLVErkwFW1)
]

---

## Hybrid Method

.pull-left[
.small[
```uml
@startuml
 while ((tmax - tmin) > tol)
    : t := (tmin + tmax) / 2;
    if (a neg. cycle C under t exists) then
       : find t' such that 
         sum{(i,j) in C | fij(t')} = 0;
       : t := t';
       : tmax := t;
    else
       : tmin := t;
    endif
 endwhile
 : t* := t;
@enduml
```
]
]
.pull-right[
![img](http://www.plantuml.com/plantuml/svg/JO_D2eD038JlFiKS17VxJu-AlVWaecjTqHMw4Irjtxt9Igcv1EQRJ9AvjRs1KZIK2uwWmJgD6sZiTGIk58GqXnA0FSIcSSOr2zGsK2MSkPzGFIiEAZ2vsZnuo2pMazUWrhZW3M6DTJLYIcBugMePbeGV1Ml3Izb3fy7B2hpPtYbAz0SvBja_9Pn4oLQHyqLSDTDxiuKSju6kjaqaRPRd8t7iLlu5)
]
---

## Improved Howard's Algorithm

.small[
.pull-left[
```uml
@startuml
 : t := (tmin + tmax) / 2;
 while (no neg. cycle under t)
    : tmin := t;
    : t := (tmin + tmax) / 2;
 endwhile
 while (a neg. cycle C under t exists)
    : find t' such that
      sum{(i,j) in C | fij(t')} = 0;
    : t := t';
 endwhile
 : t* := t;
@enduml
```
]
.pull-right[
![img](http://www.plantuml.com/plantuml/svg/TOx13i8W44Jl_Ogv0MhKUAJfgLz208L6CB7RMAF-kniCnXxSsqnstem6GNUGb6B66fJChB33eMrm2_7i8VC5sP-si7VBSihENq6g0Pz6YN6Uschye_di2l3BDR_OleBXvpZIMFd7c1r8O9ni00L3nGVhz91nCoXmKOydFmwIX7gXmtwnXSIYdDtLP_0R)
]
]

---

## Backup

```terminal
> pandoc -t beamer lec05b.md beamer.yaml -o slide05b.pdf
```

    </textarea>
    <script src="../remark-latest.min.js"></script>
    <script src="../katex/katex.min.js" type="text/javascript"></script>
    <script src="../katex/contrib/auto-render.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      renderMathInElement(
          document.getElementById("source"),
          {
              delimiters: [
                  {left: "$$", right: "$$", display: true},
                  {left: "$", right: "$", display: false}
              ]
          }
      );
      var slideshow = remark.create({
        highlightStyle: 'atom-one-light'
      });
    </script>
  </body>
</html>