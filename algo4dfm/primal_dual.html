<!doctype html>
<html>
  <head>
    <title>â˜¯ Primal-Dual Method for Approximation Algorithms</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width"
    />
    <link rel="stylesheet" type="text/css" href="../katex/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/spaces.css" />
    <link rel="stylesheet" type="text/css" href="../css/slides.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-dark.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-light.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/bg-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>
  <body>
    <textarea id="source">

layout: true
class: typo, typo-selection

---

count: false
class: nord-dark, middle, center

# â˜¯ Primal-Dual Method for Approximation Algorithms

@luk036

2024-11-20

---

## Abstract

The primal-dual method is a powerful technique in the field of approximation algorithms. Originating from linear programming and combinatorial optimization, it has been adapted to tackle NP-hard problems effectively. This presentation will explore the fundamentals, methodology, and applications of this versatile approach, demonstrating its significance in developing efficient solutions for complex computational challenges.

---

## Fundamentals of PD Method

- Dual Approach:

   The primal-dual method considers both the primal integer programming formulation and the dual of its LP relaxation. This dual perspective provides valuable insights into the problem structure.

- Iterative Improvement:

   Starting with a dual feasible solution, the method iteratively improves while constructing a primal integral solution. This process often leads to dual-ascent algorithms.

- Relaxed Conditions:

   For NP-hard problems, the method relaxes complementary slackness conditions, allowing for efficient approximation algorithms with provable guarantees.

---

## General Methodology

1. Formulate as Integer Program:

   Begin by expressing the problem as an integer programming formulation, capturing the essential constraints and objectives.

2. Consider LP Relaxation Dual:

   Analyze the dual of the linear programming relaxation, which provides a lower bound on the optimal solution.

3. Iterative Improvement:

   Incrementally increase dual variables while constructing a primal solution, ensuring feasibility and optimality conditions are maintained.

4. Approximation Analysis:

   Evaluate the approximation ratio based on the relationship between the constructed primal and dual solutions.

---

## Key Strengths of the PD Method

- Provable Approximation Guarantees:

   The method provides mathematically rigorous bounds on solution quality, ensuring reliable performance.

- Combinatorial Algorithms:

   Often leads to efficient combinatorial algorithms, avoiding the need for solving large linear programs.

- Problem Structure Insights:

   Offers deep insights into the underlying structure of complex optimization problems.

- Wide Applicability:

   Suitable for a broad range of NP-hard problems across various domains of computer science and operations research.

---

## Applications

- âš™ Problem Setup:

   Given a graph $G = (V, E)$ with edge costs, the goal is to find a minimum-cost subgraph satisfying specific connectivity requirements.

- ğ–£‚ Steiner Tree Problem:

   Connect a subset of vertices at minimum cost, a fundamental problem in network design.

- ğŸ–§ Survivable Network Design:

   Design networks resilient to failures, ensuring connectivity under various scenarios.

- ğŸ“¡ Wireless Network Design:

   Design wireless networks with limited resources, optimizing coverage and capacity.

---

## Generic PD Algorithm for Network Design

1. Initialize:

   Begin with an empty solution set $A$ and set all dual variables $y$ to 0.

2. Iterate:

   While the solution A is not feasible, identify violated connectivity requirements, increase corresponding dual variables, and add edges to $A$ when dual constraints become tight.

3. Prune:

   Remove unnecessary edges from $A$ to optimize the final solution.

---

count: false
class: nord-dark, middle, center

.pull-left[

# ğŸ™‹ Q & A

]
.pull-right[

![image](figs/questions-and-answers.svg)

]

    </textarea>
    <script src="../js/remark.min.js"></script>
    <script src="../katex/katex.min.js" type="text/javascript"></script>
    <script
      src="../katex/contrib/auto-render.min.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      renderMathInElement(document.getElementById("source"), {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      });
      var slideshow = remark.create({
        ratio: "4:3", // çª—å£æ¯”ä¾‹
        // å¯é€‰ï¼šarta, ascetic, dark, default, far, github, googlecode, idea,
        // ir-black, magula, monokai, rainbow, solarized-dark, solarized-light,
        // sunburst, tomorrow, tomorrow-night-blue, tomorrow-night-bright,
        // tomorrow-night, tomorrow-night-eighties, vs, zenburn.
        highlightStyle: "tomorrow-night-eighties",
        highlightLines: true,
        countIncrementalSlides: false, // å¢é‡å†…å®¹æ˜¯å¦ç®—ä¸€é¡µ
        // slideNumberFormat: "", // è‹¥å°†æ­¤å‚æ•°è®¾ç½®ä¸º ""ï¼Œå°†ä¸æ˜¾ç¤ºé¡µç 
        navigation: {
          scroll: false, // æ˜¯å¦å…è®¸ä½¿ç”¨é¼ æ ‡æ»šè½®ç¿»é¡µ
          touch: true, // ï¼ˆå¦‚æœæ˜¯è§¦æ‘¸å±ï¼‰æ˜¯å¦å…è®¸ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
          click: false, // æ˜¯å¦å…è®¸é¼ æ ‡ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
        },
      });
    </script>
  </body>
</html>
