<!doctype html>
<html>
  <head>
    <title>â˜¯ Primal-Dual Method for Approximation Algorithms</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width"
    />
    <link rel="stylesheet" type="text/css" href="../katex/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/spaces.css" />
    <link rel="stylesheet" type="text/css" href="../css/slides.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-dark.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-light.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/bg-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>
  <body>
    <textarea id="source">

layout: true
class: typo, typo-selection

---

count: false
class: nord-dark, middle, center

# â˜¯ Primal-Dual Method for Approximation Algorithms

@luk036 ğŸ‘¨â€ğŸ’»

2025-11-26 ğŸ“…

[![Documentation Status](https://readthedocs.org/projects/netlistx/badge/?version=latest)](https://netlistx.readthedocs.io/en/latest/?badge=latest)
[![codecov](https://codecov.io/gh/luk036/netlistx/branch/master/graph/badge.svg?token=6lpjUzPavX)](https://codecov.io/gh/luk036/netlistx)

---

### ğŸ“ Abstract

The primal-dual method is a powerful technique in the field of approximation algorithms. Originating from linear programming and combinatorial optimization, it has been adapted to tackle NP-hard problems effectively.

This lecture explores the fundamentals, methodology, and applications of this versatile approach, demonstrating its significance in developing efficient solutions for complex computational challenges that would otherwise be intractable.

---

### ğŸ§® Fundamentals of the PD Method

- Dual Approach ğŸ”„:

   The primal-dual method considers both the primal integer programming formulation and the dual of its LP relaxation. This dual perspective provides valuable insights into the problem structure.

- Iterative Improvement ğŸ”:

   Starting with a dual feasible solution, the method iteratively improves while constructing a primal integral solution. This process often leads to dual-ascent algorithms.

- Relaxed Conditions âš–ï¸:

   For NP-hard problems, the method relaxes complementary slackness conditions, allowing for efficient approximation algorithms with provable guarantees.

---

### ğŸ“š Example: Vertex Cover

- Instance: A graph $G = ({\color{salmon}V}, {\color{lime}E})$

- Solution: A vertex cover for $G$, i.e., a subset ${\color{salmon}U}$ such that, for each edge $(u,v) \in {\color{lime}E}$, at least one of $u$ and $v$ belongs to ${\color{salmon}U}$ ğŸ›¡ï¸

- Measure: Cardinality of the vertex cover, i.e. $|{\color{salmon}U}|$ ğŸ“

- Bad News: APX-complete. ğŸ˜Ÿ

- Comment: Admits a PTAS for *planar* graphs [Baker, 1994]. The generalization to $k$-hypergraphs, for $k>1$, is approximable within $k$ [Bar-Yehuda and Even, 1981] and [Hochbaum, 1982a]. ğŸ“–

- Garey and Johnson: GT1 ğŸ“š

---

### âš™ï¸ Greedy-Vertex-Cover

```
â”Œâ”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚1â”‚U = {}                                   â”‚
â”‚2â”‚do chose v in V with max. degree         â”‚
â”‚3â”‚    U = U + {v}                          â”‚
â”‚4â”‚    remove v and every edge adjacent to vâ”‚
â”‚5â”‚until all edges covered                  â”‚
â”‚6â”‚return U                                 â”‚
â””â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Requirements:

- Need a (bucket) heap to maintain max. degree âš–ï¸
- Only for unweighted problems. ğŸ‹ï¸â€â™‚ï¸

---

### âš–ï¸ Weighted Vertex Cover (WVC)

The Weighted Vertex Cover problem extends the basic vertex cover by assigning weights to vertices.

- Instance: $G = ({\color{salmon}V}, {\color{lime}E})$ with non-negative vertex weights ${\color{coral} w}: {\color{salmon}V} â†¦ N$ ğŸ·ï¸
- Solution: A vertex cover for $G$, i.e., a subset ${\color{salmon}U}$ such that, for each edge $(u,v) âˆˆ {\color{lime}E}$, at least one of $u$ and $v$ belongs to ${\color{salmon}U}$ ğŸ›¡ï¸

    ![img](./lec02.files/vertex_cover.svg)

This problem has applications in network monitoring, resource allocation, and conflict resolution in scheduling. ğŸŒ

---

### ğŸ§® Mathematical Formulation of WVC

ILP Formulation:

$$\begin{array}{lll}
  \text{minimize} & \sum_{v \in {\color{salmon}V} } {\color{coral} w}_v {\color{green} x}_v \\
  \text{subject to} & {\color{green} x}_u + {\color{green} x}_v \geq 1, & \forall (u, v) \in {\color{lime}E} \\
    & {\color{green} x}_v \in \{0, 1\}, & \forall v \in {\color{salmon}V}
\end{array}$$

LP Relaxation:

.pull-left[
Primal LP:
$$\begin{array}{lll}
  \text{min} & \sum_{v \in {\color{salmon}V} } {\color{coral} w}_v {\color{green} x}_v \\
  \text{s.t.} & {\color{green} x}_u + {\color{green} x}_v \geq 1, & \forall (u, v) \in {\color{lime}E} \\
    & 0 \leq {\color{green} x}_v \leq 1, & \forall v \in {\color{salmon}V}
\end{array}$$

]
.pull-right[

Dual LP:
$$\begin{array}{lll}
  \text{max} & \sum_{e \in {\color{lime}E} } {\color{firebrick} y}_e \\
  \text{s.t.} & \sum_{e \in \text{adj}(v)} {\color{firebrick} y}_e \leq {\color{coral} w}_v, & \forall v \in {\color{salmon}V} \\
    & {\color{firebrick} y}_e \geq 0, & \forall e \in {\color{lime}E}
\end{array}$$

]

---

### âš™ï¸ Primal-Dual Algorithm for WVC

- Initialize ğŸ

  Set all dual variables to zero. Start with empty vertex cover ${\color{salmon}U}$.

- Find Uncovered Edge ğŸ”

  Locate an edge $e=(u,v)$ not yet covered by ${\color{salmon}U}$.

- Increase Dual Variable ğŸ“ˆ

  Increase ${\color{firebrick} y}_e$ until a dual constraint becomes tight.

- Add Vertex â•

  Add the vertex with tight constraint to the cover ${\color{salmon}U}$.

---

### âš™ï¸ Primal-dual WVC

- **Input** Graph $G = ({\color{salmon}V}, {\color{lime}E})$ with non-negative vertex weights ${\color{coral} w}$
- **Output** Vertex cover ${\color{salmon}U}$ of $G$ ğŸ›¡ï¸
- Let DLP<sub>VC</sub> be the dual of the LP
  relaxation of ILP<sub>VC</sub> âš–ï¸
- ~~**for** each dual variable $y$ of DLP<sub>VC</sub> **do** $y$ := 0;~~
- ${\color{salmon}U} := 0$ ğŸ
- **while** ${\color{salmon}U}$ is not a vertex cover **do** ğŸ”
    - Let $e = (u, v)$ be an edge not covered by ${\color{salmon}U}$ ğŸ”
    - Increase ${\color{firebrick} y}_e$ until a constraint of DLP<sub>VC</sub> becomes tight ğŸ“ˆ
    - **if** $\sum_{e \in {\color{lime}E} } {\color{firebrick} y}_{e}$ is tight **then** âš–ï¸
        - ${\color{salmon}U} := {\color{salmon}U} \cup \{u\}$ â•
    - **else**
        - ${\color{salmon}U} := {\color{salmon}U} \cup \{v\}$ â•
- **return** ${\color{salmon}U}$ ğŸ¯

---

### ğŸ Python Implementation

```python
def min_vertex_cover(ugraph, weight, coverset = None):
    if coverset is None:
        coverset = set()

    total_dual_cost = 0  # for assertion
    total_prml_cost = 0
    gap = copy.copy(weight)

    for utx, vtx in ugraph.edges():
        if utx in coverset or vtx in coverset:
            continue
        if gap[utx] < gap[vtx]:
            utx, vtx = vtx, utx  # swap
        coverset.add(vtx)
        total_dual_cost += gap[vtx]
        total_prml_cost += weight[vtx]
        gap[utx] -= gap[vtx]
        gap[vtx] = 0

    assert total_dual_cost <= total_prml_cost
    return coverset, total_prml_cost
```

---

### ğŸ§  General Methodology

1. Formulate as Integer Program ğŸ“:

   Begin by expressing the problem as an integer programming formulation, capturing the essential constraints and objectives.

2. Consider LP Relaxation Dual âš–ï¸:

   Analyze the dual of the linear programming relaxation, which provides a lower bound on the optimal solution.

3. Iterative Improvement ğŸ”:

   Incrementally increase dual variables while constructing a primal solution, ensuring feasibility and optimality conditions are maintained.

4. Approximation Analysis ğŸ“Š:

   Evaluate the approximation ratio based on the relationship between the constructed primal and dual solutions.

---

### ğŸ’ª Key Strengths of the PD Method

- Provable Approximation Guarantees ğŸ’¯:

   The method provides mathematically rigorous bounds on solution quality, ensuring reliable performance.

- Combinatorial Algorithms ğŸ§©:

   Often leads to efficient combinatorial algorithms, avoiding the need for solving large linear programs.

- Problem Structure Insights ğŸ”:

   Offers deep insights into the underlying structure of complex optimization problems.

- Wide Applicability ğŸŒ:

   Suitable for a broad range of NP-hard problems across various domains of computer science and operations research.

---

### ğŸ”„ Generic PD for Cover Problems

1. Initialize ğŸ:

   Begin with an empty solution set $A$ and set all dual variables $y$ to 0.

2. Iterate ğŸ”:

   While the solution A is not feasible, identify violated connectivity requirements, increase corresponding dual variables, and add edges to $A$ when dual constraints become tight.

3. Prune âœ‚ï¸:

   Remove unnecessary edges from $A$ to optimize the final solution.

4. Return Solution ğŸ¯

   Output the optimized solution with provable approximation guarantees based on the relationship between primal and dual values.

---

### ğŸ Python Implementation

```python
def pd_cover(
    violate: Callable, weight, soln: Set
) -> Tuple[Set, Union[int, float]]:
    total_prml_cost = 0
    total_dual_cost = 0
    gap = copy.copy(weight)
    for S in violate():
        min_vtx = min(S, key=lambda vtx: gap[vtx])
        min_val = gap[min_vtx]
        soln.add(min_vtx)
        total_prml_cost += weight[min_vtx]
        total_dual_cost += min_val
        for vtx in S:
            gap[vtx] -= min_val
    assert total_dual_cost <= total_prml_cost
    return soln, total_prml_cost
```

---

### ğŸ“š Example: WVC for Hypergraph

A hypergraph extends the concept of a graph by allowing edges to connect any number of vertices. The vertex cover problem for hypergraphs requires finding a minimum weight set of vertices that intersects with every hyperedge, making it more complex than the standard graph version.

- Instance: $H = ({\color{salmon}V}, {\color{lime}E})$ with non-negative vertex weights ${\color{coral} w}: {\color{salmon}V} â†¦ N$ ğŸ·ï¸
- Solution: A vertex cover for $H$, i.e., a subset ${\color{salmon}U}$ such that, for each edge $e âˆˆ {\color{lime}E}$, at least one of adj($e$) belongs to ${\color{salmon}U}$ ğŸ›¡ï¸

    ![img](./lec02.files/hyper_vertex_cover.svg)

---

### ğŸ§® Mathematical Formulation of WVC

ILP Formulation:

$$\begin{array}{lll}
  \text{minimize} & \sum_{v \in {\color{salmon}V} } {\color{coral} w}_v {\color{green} x}_v \\
  \text{subject to} & \sum_{v \in \text{adj}(e)} {\color{green} x}_v \geq 1, & \forall e \in {\color{lime}E} \\
    & {\color{green} x}_v \in \{0, 1\}, & \forall v \in {\color{salmon}V}
\end{array}$$

LP Relaxation:

.pull-left[
Primal LP:
$$\begin{array}{lll}
  \text{min} & \sum_{v \in {\color{salmon}V} } {\color{coral} w}_v {\color{green} x}_v \\
  \text{s.t.} & \sum_{v \in \text{adj}(e)} {\color{green} x}_v \geq 1, & \forall e \in {\color{lime}E} \\
    & 0 \leq {\color{green} x}_v \leq 1, & \forall v \in {\color{salmon}V}
\end{array}$$

]
.pull-right[
Dual LP:
$$\begin{array}{lll}
  \text{max} & \sum_{e \in {\color{lime}E} } {\color{firebrick} y}_e \\
  \text{s.t.} & \sum_{e \in \text{adj}(v)} {\color{firebrick} y}_e \leq {\color{coral} w}_v, & \forall v \in {\color{salmon}V} \\
    & {\color{firebrick} y}_e \geq 0, & \forall e \in {\color{lime}E}
\end{array}$$
]

---

### ğŸ Python Implementation

```python
def min_hyper_vertex_cover(
    hgr, weight, coverset = None
) -> Tuple[Set, Union[int, float]]:
    if coverset is None:
        coverset = set()

    def violate_netlist() -> Generator:
        for net in hyprgraph.nets:
            if any(v in coverset for v in hgr.ugraph[net]):
                continue
            yield hyprgraph.ugraph[net]

    return pd_cover(violate_netlist, weight, coverset)
```

---

### ğŸ”„ Weighted Cycle Cover (WCC)

Find a minimum weight set of vertices that intersects with every cycle in the graph. This problem has applications in breaking feedback loops in systems and ensuring acyclic dependencies.

- Instance: $G = ({\color{salmon}V}, {\color{lime}E})$ with non-negative vertex weights ${\color{coral} w}: {\color{salmon}V} â†¦ N$ ğŸ·ï¸
- Define: a cycle $c$ is a subset of ${\color{salmon}V}$ ... , $C$ is a set of all cycles ğŸ”„
- Solution: A vertex cover for $G$, i.e., a subset ${\color{salmon}U}$ such that, for each cycle $c âˆˆ C$, at least one of vertices belongs to ${\color{salmon}U}$ ğŸ›¡ï¸

  ![img](./lec02.files/cycle_cover.svg)

---

### ğŸ§® Mathematical Formulation of WCC

ILP Formulation:

$$\begin{array}{lll}
  \text{minimize} & \sum_{v \in {\color{salmon}V} } {\color{coral} w}_v {\color{green} x}_v \\
  \text{subject to} & \sum_{v \in c} {\color{green} x}_v \geq 1, & \forall c \in C \\
    & {\color{green} x}_v \in \{0, 1\}, & \forall v \in {\color{salmon}V}
\end{array}$$

LP Relaxation:

.pull-left[

Primal LP:
$$\begin{array}{lll}
  \text{min} & \sum_{v \in {\color{salmon}V} } {\color{coral} w}_v {\color{green} x}_v \\
  \text{s.t.} & \sum_{v \in c} {\color{green} x}_v \geq 1, & \forall c \in C \\
    & 0 \leq {\color{green} x}_v \leq 1, & \forall v \in {\color{salmon}V}
\end{array}$$

]
.pull-right[
Dual LP:
$$\begin{array}{lll}
  \text{max} & \sum_{c \in C} {\color{firebrick} y}_c \\
  \text{s.t.} & \sum_{c: v \in c} {\color{firebrick} y}_c \leq {\color{coral} w}_v, & \forall v \in {\color{salmon}V} \\
    & {\color{firebrick} y}_c \geq 0, & \forall c \in C
\end{array}$$
]

---

### ğŸ Python Implementation

```python
def min_cycle_cover(
    ugraph: nx.Graph, weight, coverset = None
) -> Tuple[Set, Union[int, float]]:
    if coverset is None:
        coverset = set()

    def find_cycle():
        for info, parent, child in _generic_bfs_cycle(
            ugraph, coverset):
            return _construct_cycle(info, parent, child)

    def violate() -> Generator:
        while True:
            S = find_cycle()
            if S is None:
                break
            yield S

    return pd_cover(violate, weight, coverset)
```

---

### ğŸ”„ Weighted Odd Cycle Cover

Find a minimum weight set of vertices that intersects with every odd-length cycle. This problem is equivalent to making a graph bipartite by removing vertices and has applications in conflict resolution.

- Instance: $G = ({\color{salmon}V}, {\color{lime}E})$ with non-negative vertex weights ${\color{coral} w}: {\color{salmon}V} â†¦ N$ ğŸ·ï¸
- Define: an odd cycle $c$ is a subset of ${\color{salmon}V}$ ... , $C_\text{odd}$ is a set of all odd cycles 1ï¸âƒ£3ï¸âƒ£5ï¸âƒ£
- Solution: A vertex cover for $G$, i.e., a subset ${\color{salmon}U}$ such that, for each odd cycle $c âˆˆ C_\text{odd}$, at least one of vertices belongs to ${\color{salmon}U}$ ğŸ›¡ï¸

  ![img](./lec02.files/odd_cycle_cover.svg)

---

### ğŸ§® Mathematical Formulation

ILP Formulation of WOCC:

$$\begin{array}{lll}
  \text{minimize} & \sum_{v \in {\color{salmon}V} } {\color{coral} w}_v {\color{green} x}_v \\
  \text{subject to} & \sum_{v \in c} {\color{green} x}_v \geq 1, & \forall c \in C_\text{odd} \\
    & {\color{green} x}_v \in \{0, 1\}, & \forall v \in {\color{salmon}V}
\end{array}$$


LP Relaxation:

.pull-left[

Primal LP:
$$\begin{array}{lll}
  \text{min} & \sum_{v \in {\color{salmon}V} } {\color{coral} w}_v {\color{green} x}_v \\
  \text{s.t.} & \sum_{v \in c} {\color{green} x}_v \geq 1, & \forall c \in C_\text{odd} \\
    & 0 \leq {\color{green} x}_v \leq 1, & \forall v \in {\color{salmon}V}
\end{array}$$

]
.pull-right[
Dual LP:
$$\begin{array}{lll}
  \text{max} & \sum_{c \in C_\text{odd} } {\color{firebrick} y}_c \\
  \text{s.t.} & \sum_{c: v \in c} {\color{firebrick} y}_c \leq {\color{coral} w}_v, & \forall v \in {\color{salmon}V} \\
    & {\color{firebrick} y}_c \geq 0, & \forall c \in C_\text{odd}
\end{array}$$
]

---

### ğŸ Python Implementation

```python
def min_odd_cycle_cover(
    ugraph, weight, coverset = None
) -> Tuple[Set, Union[int, float]]:
    if coverset is None:
        coverset = set()

    def find_odd_cycle():
        for info, parent, child in _generic_bfs_cycle(
            ugraph, coverset):
            _, depth_child = info[child]
            _, depth_parent = info[parent]
            if (depth_parent - depth_child) % 2 == 0:
                return _construct_cycle(info, parent, child)

    def violate() -> Generator:
        while True:
            S = find_odd_cycle()
            if S is None:
                break
            yield S

    return pd_cover(violate, weight, coverset)
```

---

### ğŸ­ Applications in EDA

WOCC is used in Electronic Design Automation for Double Patterning Lithography (DPL) combined with E-beam lithography, solving coloring conflicts in semiconductor manufacturing. ğŸ–¥ï¸ğŸ”¬

![width:100%](./figs/MPL+EBL.png)

---

![width:100%](./figs/DPL+EBL.png)

---

### ğŸ§© Weighted Maximal Matching (WMM) for Hypergraph

- Instance: $H = ({\color{salmon}V}, {\color{lime}E})$ with non-negative vertex weights ${\color{coral} w}: {\color{salmon}V} â†¦ N$ ğŸ·ï¸

  ![img](./lec02.files/maximal_matching.svg)

- Application: clustering ğŸ§©

---

### ğŸ§® LP Relaxation of WMM

Primal LP:
$$\begin{array}{lll}
  \text{min} & \sum_{e \in {\color{lime}E} } {\color{coral} w}_e {\color{green} x}_e \\
  \text{s.t.} & \sum_{e \in \text{adj}(v)} {\color{green} x}_e \leq 1, & \forall v \in {\color{salmon}V} \\
   & {\color{green} x}_e + \sum_{v \in \text{adj}(e)} \sum_{f \in \text{adj}(v)} {\color{green} x}_f \geq 1, & \forall e \in {\color{lime}E}  \\
   & 0 \leq {\color{green} x}_v \leq 1, & \forall v \in {\color{salmon}V}
\end{array}$$


Dual LP:

$$\begin{array}{lll}
  \text{max} & \sum_{e \in {\color{lime}E} } {\color{firebrick} y}_e - \sum_{v \in {\color{salmon}V} } {\color{firebrick} z}_v \\
  \text{s.t.} & {\color{firebrick} y}_e + \sum_{v \in \text{adj}(e)} (-{\color{firebrick} z}_v + \sum_{f \in \text{adj}(v)} {\color{firebrick} y}_f) \leq {\color{coral} w}_e, & \forall e \in {\color{lime}E} \\
    & {\color{firebrick} y}_e \geq 0, & \forall e \in {\color{lime}E} \\
    & {\color{firebrick} z}_v \geq 0, & \forall v \in {\color{salmon}V}
\end{array}$$

---

### ğŸ Python Implementation

.font-sm.mb-xs[

```python
def min_maximal_matching(hyprgraph, weight, matchset, dep):
    def cover(net):
        for vtx in hyprgraph.ugraph[net]:
            dep.add(vtx)

    def any_of_dep(net):
        return any(vtx in dep for vtx in hyprgraph.ugraph[net])

    total_prml_cost = 0
    gap = copy.copy(weight)
    for net in hyprgraph.nets:
        if any_of_dep(net): continue
        if net in matchset: continue # pre-define matching
        min_val = gap[net]
        min_net = net
        for vtx in hyprgraph.ugraph[net]:
            for net2 in hyprgraph.ugraph[vtx]:
                if any_of_dep(net2): continue
                if min_val > gap[net2]:
                    min_val = gap[net2]
                    min_net = net2
        cover(min_net)
        matchset.add(min_net)
        total_prml_cost += weight[min_net]
        if min_net == net: continue
        gap[net] -= min_val
        for vtx in hyprgraph.ugraph[net]:
            for net2 in hyprgraph.ugraph[vtx]:
                gap[net2] -= min_val
    assert total_dual_cost <= total_prml_cost
    return matchset, total_prml_cost
```
]

---

### ğŸŒ Other Applications and Extensions

- ğŸŒ³ Steiner Tree Problem:

   Connect a subset of vertices at minimum cost, a fundamental problem in network design.

- ğŸ›¡ï¸ Survivable Network Design:

   Design networks resilient to failures, ensuring connectivity under various scenarios.

- ğŸ“¶ Wireless Network Design:

   Design wireless networks with limited resources, optimizing coverage and capacity.

---

### ğŸ¯ Conclusion

The primal-dual method stands as a significant technique in the field of approximation algorithms. Its ability to provide provable performance guarantees through a systematic approach based on linear programming duality makes it invaluable for tackling a wide array of NP-hard optimization problems. The method's success in areas like vertex cover problems, cycle cover problems, network design, and electronic design automation underscores its versatility and practical importance. By offering both theoretical guarantees and often leading to efficient combinatorial algorithms, the primal-dual method continues to be a crucial tool for addressing complex computational challenges.

---

count: false
class: nord-dark, middle, center

.pull-left[

# Q&A ğŸ¤

]
.pull-right[

![image](figs/questions-and-answers.svg)

]
    </textarea>
    <script src="../js/remark.min.js"></script>
    <script src="../katex/katex.min.js" type="text/javascript"></script>
    <script
      src="../katex/contrib/auto-render.min.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      renderMathInElement(document.getElementById("source"), {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      });
      var slideshow = remark.create({
        ratio: "4:3", // çª—å£æ¯”ä¾‹
        // å¯é€‰ï¼šarta, ascetic, dark, default, far, github, googlecode, idea,
        // ir-black, magula, monokai, rainbow, solarized-dark, solarized-light,
        // sunburst, tomorrow, tomorrow-night-blue, tomorrow-night-bright,
        // tomorrow-night, tomorrow-night-eighties, vs, zenburn.
        highlightStyle: "tomorrow-night-eighties",
        highlightLines: true,
        countIncrementalSlides: false, // å¢é‡å†…å®¹æ˜¯å¦ç®—ä¸€é¡µ
        // slideNumberFormat: "", // è‹¥å°†æ­¤å‚æ•°è®¾ç½®ä¸º ""ï¼Œå°†ä¸æ˜¾ç¤ºé¡µç 
        navigation: {
          scroll: false, // æ˜¯å¦å…è®¸ä½¿ç”¨é¼ æ ‡æ»šè½®ç¿»é¡µ
          touch: true, // ï¼ˆå¦‚æœæ˜¯è§¦æ‘¸å±ï¼‰æ˜¯å¦å…è®¸ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
          click: false, // æ˜¯å¦å…è®¸é¼ æ ‡ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
        },
      });
    </script>
  </body>
</html>
