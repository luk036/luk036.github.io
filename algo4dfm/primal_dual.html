<!doctype html>
<html>
  <head>
    <title>â˜¯ Primal-Dual Method for Approximation Algorithms</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width"
    />
    <link rel="stylesheet" type="text/css" href="../katex/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/spaces.css" />
    <link rel="stylesheet" type="text/css" href="../css/slides.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-dark.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-light.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/bg-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>
  <body>
    <textarea id="source">

layout: true
class: typo, typo-selection

---

count: false
class: nord-dark, middle, center

# â˜¯ Primal-Dual Method for Approximation Algorithms

@luk036

2024-11-20

---

## Abstract

The primal-dual method is a "powerful" technique in the field of approximation algorithms. Originating from linear programming and combinatorial optimization, it has been adapted to tackle NP-hard problems effectively. This presentation will explore the fundamentals, methodology, and applications of this versatile approach, demonstrating its significance in developing efficient solutions for complex computational challenges.

---

## Fundamentals of PD Method

- Dual Approach:

   The primal-dual method considers both the primal integer programming formulation and the dual of its LP relaxation. This dual perspective provides valuable insights into the problem structure.

- Iterative Improvement:

   Starting with a dual feasible solution, the method iteratively improves while constructing a primal integral solution. This process often leads to dual-ascent algorithms.

- Relaxed Conditions:

   For NP-hard problems, the method relaxes complementary slackness conditions, allowing for efficient approximation algorithms with provable guarantees.

---

## Example: Vertex Cover

- Instance: $G = (V, E)$ 

- Solution: A vertex cover for $G$, i.e., a subset $U$ such that, for each edge $(u,v) \in E$, at least one of $u$ and $v$ belongs to $U$

- Measure: Cardinality of the vertex cover, i.e. $|U|$

- Bad News: APX-complete.

- Comment: Admits a PTAS for *planar* graphs [Baker, 1994]. The generalization to $k$-hypergraphs, for $k>1$, is approximable within $k$ [Bar-Yehuda and Even, 1981] and [Hochbaum, 1982a].

- Garey and Johnson: GT1

---

## Greedy-Vertex-Cover

```
â”Œâ”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚1â”‚U = {}                                   â”‚
â”‚2â”‚do chose v in V with max. degree         â”‚
â”‚3â”‚    U = U + {v}                          â”‚
â”‚4â”‚    remove v and every edge adjacent to vâ”‚
â”‚5â”‚until all edges covered                  â”‚
â”‚6â”‚return U                                 â”‚
â””â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Requirements:

- Need a (bucket) heap to maintain max. degree
- Only for unweighted problems.

---

## Weighted Vertex Cover (WVC)

- Instance: $G = (V, E)$ with non-negative vertex weights $w: V â†¦ N$
- Solution: A vertex cover for $G$, i.e., a subset $U$ such that, for each edge $(u,v) âˆˆ E$, at least one of $u$ and $v$ belongs to $U$

```
    "({b, d, e}, 3)"

    b     c     d     e
    #-----o-----#-----o
    |      \   / \
    |       \ /   \
    o        #-----o
    a        e     f
```

---

## ILP Formulation of WVC

```
         ___
min      â•²   w  â‹… x
         â•±    v    v
         â€¾â€¾â€¾
         vâˆˆV

s.t.    x  + x  â‰¥ 1, âˆ€ (u, v) âˆˆ E
         u    v

        x  âˆˆ {0, 1}, âˆ€ v âˆˆ V.
         v
```

---

## LP Relaxation of WVC

.pull-left[
Primal LP:
```
         ___
min      â•²   w  â‹… x
         â•±    v    v
         â€¾â€¾â€¾
         vâˆˆV

s.t.    x  + x  â‰¥ 1, âˆ€ (u, v) âˆˆ E      
         u    v          

        0 â‰¤ x  â‰¤ 1, âˆ€ v âˆˆ V.
             v    
```
]
.pull-right[

Dual LP:
```
         ___    
max      â•²   y    
         â•±    e    
         â€¾â€¾â€¾    
         eâˆˆE    
       ___          
s.t.   â•²   y  â‰¤ w , âˆ€ v âˆˆ V,
       â•±    e    v
       â€¾â€¾â€¾          
      eâˆˆadj(v)

        y  â‰¥ 0, âˆ€ e âˆˆ E.
         e              
```
]

---

## Primal-dual WVC

- **Input** Graph $G = (V, E)$ with non-negative vertex weights $w$;
- **Output** Vertex cover $U$ of $G$;
- Let DLP<sub>VC</sub> be the dual of the LP
  relaxation of ILP<sub>VC</sub>;
- ~~**for** each dual variable $y$ of DLP<sub>VC</sub> **do** $y$ := 0;~~
- $U := 0$;
- **while** $U$ is not a vertex cover **do**
    - Let $e = (u, v)$ be an edge not covered by $U$;
    - Increase $y_e$ until a constraint of DLP<sub>VC</sub> becomes tight;
    - **if** $\sum_{e \in E} y_{e}$ is tight **then**
        - $U := U \cup \{u\}$
    - **else**
        - $U := U \cup \{v\}$
- **return** $U$

---

## Python Implementation

```python
def min_vertex_cover(ugraph, weight, coverset = None):
    if coverset is None:
        coverset = set()

    total_dual_cost = 0  # for assertion
    total_prml_cost = 0
    gap = copy.copy(weight)

    for utx, vtx in ugraph.edges():
        if utx in coverset or vtx in coverset:
            continue
        if gap[utx] < gap[vtx]:
            utx, vtx = vtx, utx  # swap
        coverset.add(vtx)
        total_dual_cost += gap[vtx]
        total_prml_cost += weight[vtx]
        gap[utx] -= gap[vtx]
        gap[vtx] = 0

    assert total_dual_cost <= total_prml_cost
    return coverset, total_prml_cost
```

---

## General Methodology

1. Formulate as Integer Program:

   Begin by expressing the problem as an integer programming formulation, capturing the essential constraints and objectives.

2. Consider LP Relaxation Dual:

   Analyze the dual of the linear programming relaxation, which provides a lower bound on the optimal solution.

3. Iterative Improvement:

   Incrementally increase dual variables while constructing a primal solution, ensuring feasibility and optimality conditions are maintained.

4. Approximation Analysis:

   Evaluate the approximation ratio based on the relationship between the constructed primal and dual solutions.

---

## Key Strengths of the PD Method

- Provable Approximation Guarantees:

   The method provides mathematically rigorous bounds on solution quality, ensuring reliable performance.

- Combinatorial Algorithms:

   Often leads to efficient combinatorial algorithms, avoiding the need for solving large linear programs.

- Problem Structure Insights:

   Offers deep insights into the underlying structure of complex optimization problems.

- Wide Applicability:

   Suitable for a broad range of NP-hard problems across various domains of computer science and operations research.

---

## Generic PD Algorithm for Cover Problems

1. Initialize:

   Begin with an empty solution set $A$ and set all dual variables $y$ to 0.

2. Iterate:

   While the solution A is not feasible, identify violated connectivity requirements, increase corresponding dual variables, and add edges to $A$ when dual constraints become tight.

3. Prune:

   Remove unnecessary edges from $A$ to optimize the final solution.

---

## Python Implementation

```python
def pd_cover(
    violate: Callable, weight, soln: Set
) -> Tuple[Set, Union[int, float]]:
    total_prml_cost = 0
    total_dual_cost = 0
    gap = copy.copy(weight)
    for S in violate():
        min_vtx = min(S, key=lambda vtx: gap[vtx])
        min_val = gap[min_vtx]
        soln.add(min_vtx)
        total_prml_cost += weight[min_vtx]
        total_dual_cost += min_val
        for vtx in S:
            gap[vtx] -= min_val
    assert total_dual_cost <= total_prml_cost
    return soln, total_prml_cost
```

---

## Example: WVC for Hypergraph

- Instance: $H = (V, E)$ with non-negative vertex weights $w: V â†¦ N$
- Solution: A vertex cover for $H$, i.e., a subset $U$ such that, for each edge $e âˆˆ E$, at least one of adj($e$) belongs to $U$

```
    "({b, d, g, h}, 4)"

    a       b        e       g
    o-------#-----+--o-------#
                  |  |
               ,--)--'
               |  |
               |  `--.
               |     |
    o-------#--+-----o-------#
    c       d        f       h
```

---

## ILP Formulation of WVC

```
         ___
min      â•²   w  â‹… x
         â•±    v    v
         â€¾â€¾â€¾
         vâˆˆV
       ___          
s.t.   â•²   x  â‰¥ 1 , âˆ€ e âˆˆ E,
       â•±    v    
       â€¾â€¾â€¾          
    vâˆˆadj(e)

        x  âˆˆ {0, 1}, âˆ€ v âˆˆ V.      
             v 
```

---

## LP Relaxation of WVC

.pull-left[
Primal LP:
```
         ___
min      â•²   w  â‹… x
         â•±    v    v
         â€¾â€¾â€¾
         vâˆˆV
       ___          
s.t.   â•²   x  â‰¥ 1 , âˆ€ e âˆˆ E,
       â•±    v    
       â€¾â€¾â€¾          
    vâˆˆadj(e)

        0 â‰¤ x  â‰¤ 1, âˆ€ v âˆˆ V.
             v    
```

]
.pull-right[
Dual LP:
```
         ___    
max      â•²   y    
         â•±    e    
         â€¾â€¾â€¾    
         eâˆˆE
       ___          
s.t.   â•²   y  â‰¤ w , âˆ€ v âˆˆ V,
       â•±    e    v
       â€¾â€¾â€¾          
    eâˆˆadj(v)

        y  â‰¥ 0, âˆ€ e âˆˆ E.
         e              
```
]

---

## Python Implementation

```python
def min_hyper_vertex_cover(
    hgr, weight, coverset = None
) -> Tuple[Set, Union[int, float]]:
    if coverset is None:
        coverset = set()

    def violate_netlist() -> Generator:
        for net in hyprgraph.nets:
            if any(v in coverset for v in hgr.ugraph[net]):
                continue
            yield hyprgraph.ugraph[net]

    return pd_cover(violate_netlist, weight, coverset)
```

---

## Weighted Cycle Cover (WCC)

- Instance: $G = (V, E)$ with non-negative vertex weights $w: V â†¦ N$
- Define: a cycle $c$ is a subset of $V$ ... , $C$ is a set of all cycles
- Solution: A vertex cover for $G$, i.e., a subset $U$ such that, for each cycle $c âˆˆ C$, at least one of vertices belongs to $U$

```
    "({c, d}, 2)"

    a     b     c
    o-----o-----#
     \   / \     \
      \ /   \     \
       #-----o-----o
       d     e     f
```

---

## ILP Formulation of WCC

```
         ___
min      â•²   w  â‹… x
         â•±    v    v
         â€¾â€¾â€¾
         vâˆˆV
       ___          
s.t.   â•²   x  â‰¥ 1 , âˆ€ c âˆˆ C,
       â•±    v    
       â€¾â€¾â€¾          
       vâˆˆc

        x  âˆˆ {0, 1}, âˆ€ v âˆˆ V.      
         v 
```

---

## LP Relaxation of WCC

.pull-left[

Primal LP:
```
         ___
min      â•²   w  â‹… x
         â•±    v    v
         â€¾â€¾â€¾
         vâˆˆV

       ___          
s.t.   â•²   x  â‰¥ 1 , âˆ€ c âˆˆ C,
       â•±    v    
       â€¾â€¾â€¾          
       vâˆˆc

        0 â‰¤ x  â‰¤ 1, âˆ€ v âˆˆ V.
             v    
```
]
.pull-right[

Dual LP:
```
         ___
max      â•²   y
         â•±    c
         â€¾â€¾â€¾
         câˆˆC

       ___          
s.t.   â•²   y  â‰¤ w , âˆ€ v âˆˆ V,
       â•±    c    v
       â€¾â€¾â€¾          
      c: vâˆˆc

        y  â‰¥ 0, âˆ€ c âˆˆ C.
         c              
```
]

---

## Python Implementation

```python
def min_cycle_cover(
    ugraph: nx.Graph, weight, coverset = None
) -> Tuple[Set, Union[int, float]]:
    if coverset is None:
        coverset = set()

    def find_cycle():
        for info, parent, child in _generic_bfs_cycle(
            ugraph, coverset):
            return _construct_cycle(info, parent, child)

    def violate() -> Generator:
        while True:
            S = find_cycle()
            if S is None:
                break
            yield S

    return pd_cover(violate, weight, coverset)
```

---

## Weighted Odd Cycle Cover (WOCC)

- Instance: $G = (V, E)$ with non-negative vertex weights $w: V â†¦ N$
- Define: an odd cycle $c$ is a subset of $V$ ... , $C$ is a set of all odd cycles
- Solution: A vertex cover for $G$, i.e., a subset $U$ such that, for each odd cycle $c âˆˆ C$, at least one of vertices belongs to $U$

```
    "({d}, 1)"

    a     b     c
    o-----o-----o
     \   / \     \
      \ /   \     \
       #-----o-----o
       d     e     f
```

---

## ILP Formulation of WOCC

```
         ___
min      â•²   w  â‹… x
         â•±    v    v
         â€¾â€¾â€¾
         vâˆˆV
       ___          
s.t.   â•²   x  â‰¥ 1 , âˆ€ c âˆˆ C,
       â•±    v    
       â€¾â€¾â€¾          
       vâˆˆc

        x  âˆˆ {0, 1}, âˆ€ v âˆˆ V.      
         v 
```

---

## LP Relaxation of WOCC

.pull-left[

Primal LP:
```
         ___
min      â•²   w  â‹… x
         â•±    v    v
         â€¾â€¾â€¾
         vâˆˆV

       ___          
s.t.   â•²   x  â‰¥ 1 , âˆ€ c âˆˆ C,
       â•±    v    
       â€¾â€¾â€¾          
       vâˆˆc
        0 â‰¤ x  â‰¤ 1, âˆ€ v âˆˆ V.
             v    
```
]
.pull-right[

Dual LP:
```
         ___
max      â•²   y
         â•±    c
         â€¾â€¾â€¾
         câˆˆC

       ___          
s.t.   â•²   y  â‰¤ w , âˆ€ v âˆˆ V,
       â•±    c    v
       â€¾â€¾â€¾          
      c: vâˆˆc

        y  â‰¥ 0, âˆ€ c âˆˆ C.
         c              
```
]

---

## Python Implementation

```python
def min_odd_cycle_cover(
    ugraph, weight, coverset = None
) -> Tuple[Set, Union[int, float]]:
    if coverset is None:
        coverset = set()

    def find_odd_cycle():
        for info, parent, child in _generic_bfs_cycle(
            ugraph, coverset):
            _, depth_child = info[child]
            _, depth_parent = info[parent]
            if (depth_parent - depth_child) % 2 == 0:
                return _construct_cycle(info, parent, child)

    def violate() -> Generator:
        while True:
            S = find_odd_cycle()
            if S is None:
                break
            yield S

    return pd_cover(violate, weight, coverset)
```

---

## Applications in DPL + E-beam

![width:100%](./figs/MPL+EBL.png)

---

![width:100%](./figs/DPL+EBL.png)

---

## Other Applications

- âš™ Problem Setup:

   Given a graph $G = (V, E)$ with edge costs, the goal is to find a minimum-cost subgraph satisfying specific connectivity requirements.

- ğ–£‚ Steiner Tree Problem:

   Connect a subset of vertices at minimum cost, a fundamental problem in network design.

- ğŸ–§ Survivable Network Design:

   Design networks resilient to failures, ensuring connectivity under various scenarios.

- ğŸ“¡ Wireless Network Design:

   Design wireless networks with limited resources, optimizing coverage and capacity.

---

## Weighted Maximal Matching (WMM) for Hypergraph

- Instance: $H = (V, E)$ with non-negative vertex weights $w: V â†¦ N$

```
    a       b        e       g
    o=======o-----+--o=======o
                  |  |
               ,--)--'
               |  |
               |  `--.
               |     |
    o=======o--+-----o=======o
    c       d        f       h
```

---

## ILP Formulation of WMM

```
         ___
min      â•²   w  â‹… x
         â•±    e    e
         â€¾â€¾â€¾
         eâˆˆE

       ___          
s.t.   â•²   x  â‰¤ 1 , âˆ€ v âˆˆ V,
       â•±    e    
       â€¾â€¾â€¾          
     eâˆˆadj(v)

                ___     ___         
        x  +    â•²       â•²    x  â‰¥ 1,   âˆ€ e âˆˆ E,
         e      â•±       â•±     f    
                â€¾â€¾â€¾     â€¾â€¾â€¾         
             vâˆˆadj(e) fâˆˆadj(v)

        x  âˆˆ {0, 1}, âˆ€ v âˆˆ V.
         v 
```

---

## LP Relaxation of WMM

.pull-left[

Primal LP:
```
         ___
min      â•²   w  â‹… x
         â•±    e    e
         â€¾â€¾â€¾
         eâˆˆE
       ___          
s.t.   â•²   x  â‰¤ 1 , âˆ€ v âˆˆ V,
       â•±    e    
       â€¾â€¾â€¾
      eâˆˆadj(v)
                ___     ___         
        x  +    â•²       â•²    x  â‰¥ 1,
         e      â•±       â•±     f    
                â€¾â€¾â€¾     â€¾â€¾â€¾         
              vâˆˆadj(e) fâˆˆadj(v)

        0 â‰¤ x  â‰¤ 1, âˆ€ v âˆˆ V.
             v    
```

]
.pull-right[

Dual LP:

```
        ___        ___         
max     â•²   y  -   â•²    z  
        â•±    e     â•±     v    
        â€¾â€¾â€¾        â€¾â€¾â€¾         
        eâˆˆE        vâˆˆV      

           ___ â›       ___     â    
s.t.   y + â•²   âœ-z  +  â•²    y  âŸ  â‰¤ w
        e  â•±   âœ  v    â•±     f âŸ     e
           â€¾â€¾â€¾ â       â€¾â€¾â€¾     â     
         vâˆˆadj(e)   fâˆˆadj(v)

        y  â‰¥ 0, âˆ€ e âˆˆ E.
         e              

        z  â‰¥ 0, âˆ€ v âˆˆ V.
         v              
```
]

---

count: false
class: nord-dark, middle, center

.pull-left[

# ğŸ™‹ Q & A

]
.pull-right[

![image](figs/questions-and-answers.svg)

]

    </textarea>
    <script src="../js/remark.min.js"></script>
    <script src="../katex/katex.min.js" type="text/javascript"></script>
    <script
      src="../katex/contrib/auto-render.min.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      renderMathInElement(document.getElementById("source"), {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      });
      var slideshow = remark.create({
        ratio: "4:3", // çª—å£æ¯”ä¾‹
        // å¯é€‰ï¼šarta, ascetic, dark, default, far, github, googlecode, idea,
        // ir-black, magula, monokai, rainbow, solarized-dark, solarized-light,
        // sunburst, tomorrow, tomorrow-night-blue, tomorrow-night-bright,
        // tomorrow-night, tomorrow-night-eighties, vs, zenburn.
        highlightStyle: "tomorrow-night-eighties",
        highlightLines: true,
        countIncrementalSlides: false, // å¢é‡å†…å®¹æ˜¯å¦ç®—ä¸€é¡µ
        // slideNumberFormat: "", // è‹¥å°†æ­¤å‚æ•°è®¾ç½®ä¸º ""ï¼Œå°†ä¸æ˜¾ç¤ºé¡µç 
        navigation: {
          scroll: false, // æ˜¯å¦å…è®¸ä½¿ç”¨é¼ æ ‡æ»šè½®ç¿»é¡µ
          touch: true, // ï¼ˆå¦‚æœæ˜¯è§¦æ‘¸å±ï¼‰æ˜¯å¦å…è®¸ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
          click: false, // æ˜¯å¦å…è®¸é¼ æ ‡ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
        },
      });
    </script>
  </body>
</html>
