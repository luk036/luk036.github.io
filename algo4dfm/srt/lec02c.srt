1
00:00:00,256 --> 00:00:06,144
好，这一节课我想简单介绍一下

2
00:00:06,400 --> 00:00:10,240
关于优化的算法

3
00:00:12,544 --> 00:00:18,688
关于这个优化

4
00:00:18,944 --> 00:00:23,296
大概可以分成两类，

5
00:00:23,552 --> 00:00:25,856
一种是continuous

6
00:00:26,368 --> 00:00:31,488
另外一种是discrete。continuous是连续的

7
00:00:31,744 --> 00:00:35,072
discrete是离散的

8
00:00:35,840 --> 00:00:41,984
continuous的话呢

9
00:00:42,240 --> 00:00:44,800
基本上是

10
00:00:46,080 --> 00:00:50,944
跟这个我们熟知的数值分析

11
00:00:51,200 --> 00:00:52,224
差不多。

12
00:00:53,504 --> 00:00:57,856
比方说这个线性规划

13
00:00:58,368 --> 00:01:02,208
还有这个凸优化

14
00:01:03,488 --> 00:01:09,632
然后这一节课主要是

15
00:01:09,888 --> 00:01:12,192
先讲这个部分

16
00:01:12,960 --> 00:01:17,056
然后离散的部分就是下一节课

17
00:01:17,824 --> 00:01:23,968
的内容。虽然分是这样子分，但是实际的问题

18
00:01:24,224 --> 00:01:24,736
当中，

19
00:01:25,248 --> 00:01:29,856
有可能一个问题它会包含

20
00:01:30,624 --> 00:01:34,208
离散的部分跟连续的

21
00:01:34,464 --> 00:01:35,232
部分的

22
00:01:35,744 --> 00:01:38,560
一般来说

23
00:01:38,816 --> 00:01:39,840
会

24
00:01:40,864 --> 00:01:45,216
把一个问题，有两种的话呢，你就把它拆开

25
00:01:45,472 --> 00:01:47,520
拆成....

26
00:01:47,776 --> 00:01:52,128
把一个问题作为另外一个问题的一个子问题

27
00:01:52,384 --> 00:01:53,664
来处理，

28
00:01:54,944 --> 00:02:01,088
所以在就分开来讨论

29
00:02:02,880 --> 00:02:06,464
另外一种分类的方法是

30
00:02:08,512 --> 00:02:12,864
没有约束条件，没有约束的跟有约束的

31
00:02:21,312 --> 00:02:26,432
关于连续的部分

32
00:02:26,944 --> 00:02:30,272
大概也可以再细分

33
00:02:33,600 --> 00:02:37,184
第一种分的方法是

34
00:02:37,952 --> 00:02:40,000
它到底是

35
00:02:41,536 --> 00:02:45,632
differentiable还是non-differentiable

36
00:02:46,400 --> 00:02:47,424
就是

37
00:02:47,936 --> 00:02:54,080
等于说，这个函数是平滑的还是不平滑的

38
00:02:57,408 --> 00:03:03,040
这里这些约束条件我是意思是。

39
00:03:05,088 --> 00:03:06,880
然后

40
00:03:08,672 --> 00:03:12,512
另外一种分的方法

41
00:03:13,792 --> 00:03:15,072
是这个

42
00:03:15,840 --> 00:03:21,216
一个叫convex跟non-convex的方法

43
00:03:22,496 --> 00:03:25,312
convex这个概念

44
00:03:28,128 --> 00:03:34,272
我觉得就比较重要。基本上

45
00:03:34,528 --> 00:03:37,600
现在你拿到一个

46
00:03:39,904 --> 00:03:46,048
优化的问题，其实你第一个问题现在

47
00:03:46,304 --> 00:03:51,424
要问的就是这个问题：它是不是

48
00:03:51,936 --> 00:03:58,080
convex。如果它是convex的话呢就是说这个就

49
00:03:58,336 --> 00:04:04,480
比较容易解决的。有方法可以比较简单比较快

50
00:04:04,736 --> 00:04:05,504
就解决

51
00:04:09,088 --> 00:04:15,232
然后我们熟悉的，以前我们就是通常第一个问题

52
00:04:15,488 --> 00:04:18,559
就会问，到底它是linear，

53
00:04:19,071 --> 00:04:22,399
就是线性的还是非线性的

54
00:04:22,911 --> 00:04:25,471
然后呢，以前的话我们就觉得，

55
00:04:25,983 --> 00:04:32,127
只要是线性的问题那我们已经有一些很好的

56
00:04:32,383 --> 00:04:34,431
工具，所以

57
00:04:34,943 --> 00:04:39,039
线性的问题一般认为比较容易解决了

58
00:04:40,063 --> 00:04:44,415
然后如果是非线性的话呢我们可能都

59
00:04:45,439 --> 00:04:51,583
为马上就考虑：能不能够把它做一个

60
00:04:51,839 --> 00:04:52,607
approximation，

61
00:04:52,863 --> 00:04:55,679
就把它变成一个线性的问题。

62
00:04:56,447 --> 00:04:59,775
以前的做法很多时候都是

63
00:05:00,031 --> 00:05:01,567
怎样子的。

64
00:05:02,591 --> 00:05:05,407
但是慢慢慢慢的话呢

65
00:05:05,919 --> 00:05:09,503
现在其实不是这样子了

66
00:05:10,015 --> 00:05:15,391
不是以这个线性跟非线性来分，而是以这个

67
00:05:17,951 --> 00:05:21,279
它是凸还是还是非凸的问题（来分）。

68
00:05:22,047 --> 00:05:22,815
如果你

69
00:05:23,327 --> 00:05:29,471
碰到一个非凸的问题，有些时候你就想办法可能做一些transformation

70
00:05:30,751 --> 00:05:36,383
或是做一些approximation把它近似尽量往这个去靠。

71
00:05:36,895 --> 00:05:42,271
不过，现在就有一些很好的工具

72
00:05:42,527 --> 00:05:43,807
解决这个

73
00:05:45,087 --> 00:05:48,159
凸优化的问题

74
00:05:49,951 --> 00:05:56,095
另外一个我们比较熟悉的就是Quadractic，二次

75
00:05:58,911 --> 00:06:01,215
问题，

76
00:06:02,495 --> 00:06:06,847
其实那就是二次的问题

77
00:06:12,223 --> 00:06:17,599
很多以前有些同学他会觉得这个

78
00:06:17,855 --> 00:06:19,647
也是比较容易

79
00:06:19,903 --> 00:06:20,671
解决。

80
00:06:21,439 --> 00:06:25,279
其实不是的，有一些二次的问题

81
00:06:25,791 --> 00:06:27,839
是非常难解决的

82
00:06:29,631 --> 00:06:35,519
主要就是看里边有一个matrix，有一个矩阵

83
00:06:36,031 --> 00:06:42,175
这个矩阵如果它是一个所谓的正定的矩阵的话呢

84
00:06:43,967 --> 00:06:45,503
那它就是

85
00:06:45,759 --> 00:06:50,623
它这个问题就是一个属于convex的，属于convex

86
00:06:50,879 --> 00:06:52,415
就比较容易解决

87
00:06:52,927 --> 00:06:56,767
但如果这个矩阵它不是正定的话呢

88
00:06:58,303 --> 00:07:01,119
其实它就，

89
00:07:01,375 --> 00:07:04,191
非常难解决

90
00:07:06,495 --> 00:07:11,871
所以第一个问题就是你要先问那个它是不是一个

91
00:07:12,383 --> 00:07:18,527
凸优化的问题。然后这个linear的，linear programming

92
00:07:18,783 --> 00:07:20,319
其实也是

93
00:07:21,343 --> 00:07:23,391
可以看成是一个

94
00:07:23,903 --> 00:07:27,743
凸优化的一部分的

95
00:07:28,767 --> 00:07:34,911
只不过linear programming的话呢，我们有另外一些解决的

96
00:07:35,167 --> 00:07:36,191
方法

97
00:07:37,727 --> 00:07:42,079
一个叫simplex method

98
00:07:43,615 --> 00:07:45,919
一个比较有效的方法

99
00:07:48,735 --> 00:07:54,367
怎么解决这个方法那就现在我就

100
00:07:54,623 --> 00:08:00,767
不说了，因为现在你随便找一个工具包，都会

101
00:08:01,791 --> 00:08:02,815
帮你

102
00:08:03,327 --> 00:08:04,607
它会帮你做的

103
00:08:10,495 --> 00:08:16,639
它这个linear programming就有一个所谓的标准的形式

104
00:08:17,919 --> 00:08:24,063
通常算法它都会其实针对这个标准来

105
00:08:25,343 --> 00:08:28,671
做的。比方说我minimize这个，

106
00:08:28,927 --> 00:08:32,511
这个C是一个向量

107
00:08:33,535 --> 00:08:34,559
然后

108
00:08:35,327 --> 00:08:37,631
代表这个是

109
00:08:38,399 --> 00:08:40,447
Cost

110
00:08:43,519 --> 00:08:47,871
x是design variable

111
00:08:48,383 --> 00:08:50,431
A是一个矩阵

112
00:08:50,687 --> 00:08:51,967
A乘x

113
00:08:52,223 --> 00:08:53,759
等于b

114
00:08:55,551 --> 00:09:01,695
就是它这个约束条件，而且x这样写就是说x的

115
00:09:01,951 --> 00:09:04,767
每一个element都是大于等于零

116
00:09:05,535 --> 00:09:09,375
然后呢，我要最小化这个

117
00:09:09,631 --> 00:09:12,191
这个目标函数。

118
00:09:16,799 --> 00:09:21,407
但因为线性规划有很多种

119
00:09:22,687 --> 00:09:27,039
写法的，这个其实只是其中

120
00:09:28,831 --> 00:09:32,159
一种写法。

121
00:09:33,695 --> 00:09:39,327
比方说这个例子的好你这个问题

122
00:09:40,863 --> 00:09:47,007
你知道你下面这个可以写成一个矩阵

123
00:09:51,871 --> 00:09:53,663
大概这样子

124
00:09:53,919 --> 00:10:00,063
然后呢现在只要你把这个能够写出来然后呢你把它变成一个

125
00:10:00,575 --> 00:10:01,599
矩阵

126
00:10:01,855 --> 00:10:05,183
然后就有一些

127
00:10:06,207 --> 00:10:12,351
软件包就可以帮你解出这个x1、x2、x3这个答案

128
00:10:12,607 --> 00:10:14,655
出来给你这个答案

129
00:10:15,679 --> 00:10:21,823
如果无解的话呢，它就告诉你这个无解

130
00:10:24,895 --> 00:10:31,039
如果它不是一个标准的形式就怎么样呢？

131
00:10:32,575 --> 00:10:38,719
不是标准的话呢，其实就有一个定理

132
00:10:38,975 --> 00:10:41,023
任何一个

133
00:10:41,535 --> 00:10:43,839
linear programming的问题

134
00:10:44,863 --> 00:10:48,191
它都可以为把它变成一个标准的

135
00:10:49,215 --> 00:10:51,007
形式

136
00:10:52,287 --> 00:10:57,663
比方说这个呢刚才

137
00:10:57,919 --> 00:10:59,967
在这个标准的

138
00:11:00,223 --> 00:11:06,367
形式上面，这个variables一定要大于等于零

139
00:11:06,623 --> 00:11:12,767
那你可能问如果我有一个variable，

140
00:11:13,791 --> 00:11:18,911
但是它没有这个限制的那怎么办呢？

141
00:11:20,959 --> 00:11:27,103
那其实你可以把这个variable

142
00:11:27,359 --> 00:11:29,407
拆成两个

143
00:11:30,687 --> 00:11:36,063
就变成x1减去x2

144
00:11:36,319 --> 00:11:42,463
然后x1、x2就可以是大于等于零

145
00:11:42,719 --> 00:11:48,863
但是原来这个x

146
00:11:50,655 --> 00:11:56,799
没有这个限制的，所以你做一个很简单的一个

147
00:11:57,055 --> 00:11:58,847
变换就可以

148
00:11:59,103 --> 00:12:02,943
变成一个标准的一个（形式）。

149
00:12:03,199 --> 00:12:07,039
或是说我这个约束条件里边呢

150
00:12:07,551 --> 00:12:11,903
现在是等于、等号、就是个等号

151
00:12:12,671 --> 00:12:13,439
这个等号

152
00:12:13,951 --> 00:12:15,999
如果我这个

153
00:12:16,255 --> 00:12:18,047
问题它不是

154
00:12:18,303 --> 00:12:22,911
等于的，它是大于等于、小于等于

155
00:12:23,423 --> 00:12:24,959
那怎么办呢？

156
00:12:26,751 --> 00:12:30,591
其实你就可以

157
00:12:30,847 --> 00:12:32,895
引入一个叫slack

158
00:12:33,407 --> 00:12:34,175
variable

159
00:12:38,271 --> 00:12:41,343
这个slack就是

160
00:12:42,111 --> 00:12:45,951
有，然后

161
00:12:46,975 --> 00:12:50,303
定义这个y

162
00:12:52,351 --> 00:12:53,887
等于

163
00:12:54,399 --> 00:12:54,911
b，

164
00:12:55,167 --> 00:12:57,983
b减去这个A x

165
00:13:00,287 --> 00:13:06,431
然后就减一个新的x跟一个新的

166
00:13:06,687 --> 00:13:07,455
A

167
00:13:07,711 --> 00:13:09,503
新的X

168
00:13:09,759 --> 00:13:15,903
就是包含了这个原来的，还有这个

169
00:13:16,159 --> 00:13:21,279
slack variable y

170
00:13:21,535 --> 00:13:25,887
这个新的A包含原来的A

171
00:13:26,143 --> 00:13:32,287
再加上这个其实应该是一个vector，这个vector里边

172
00:13:32,543 --> 00:13:37,407
的Element全都是1

173
00:13:41,503 --> 00:13:47,647
然后

174
00:13:50,975 --> 00:13:57,119
....变成一个....

175
00:13:57,375 --> 00:14:02,239
这个约束条件就全都是等号了

176
00:14:02,495 --> 00:14:08,639
这个要

177
00:14:15,295 --> 00:14:20,927
原来这个是....本来这个是

178
00:14:23,743 --> 00:14:26,047
这样子嘛....

179
00:14:26,559 --> 00:14:32,191
现在就变成了这个

180
00:14:32,703 --> 00:14:34,495
所以这个A

181
00:14:38,079 --> 00:14:43,455
乘上这个x，A'

182
00:14:43,967 --> 00:14:45,247
这个

183
00:14:48,575 --> 00:14:53,951
正好是相等

184
00:14:59,327 --> 00:15:05,215
然后呢还有一个就是如果你现在说，我这个是minimize，

185
00:15:06,239 --> 00:15:07,775
如果我是

186
00:15:08,543 --> 00:15:09,567
Maximize

187
00:15:11,103 --> 00:15:12,639
那怎么做呢？

188
00:15:13,407 --> 00:15:17,503
这个就更简单了，只要你把里边这个

189
00:15:21,087 --> 00:15:23,391
变成一个负

190
00:15:26,719 --> 00:15:30,815
maximize一个expression然后你就是相当于minimize这个

191
00:15:31,071 --> 00:15:33,119
它的这个负

192
00:15:34,399 --> 00:15:35,423
就可以了

193
00:15:37,983 --> 00:15:44,127
当然了现在的软件包可能就更聪明一点的就是

194
00:15:44,639 --> 00:15:47,967
随便你怎么写然后呢它自己这个

195
00:15:48,223 --> 00:15:50,527
program里边就

196
00:15:50,783 --> 00:15:52,575
自动就帮你转了

197
00:15:53,343 --> 00:15:55,391
它解完之后呢

198
00:15:55,647 --> 00:15:58,719
再把这个答案了再转回来

199
00:15:59,231 --> 00:16:01,279
所以

200
00:16:02,303 --> 00:16:06,399
可能这个都不用你去自己做了。

201
00:16:11,519 --> 00:16:14,591
然后关于这个对偶性

202
00:16:15,359 --> 00:16:16,383
duality

203
00:16:16,639 --> 00:16:18,687
就是

204
00:16:18,943 --> 00:16:22,527
所有的 linear programming 的问题

205
00:16:24,063 --> 00:16:27,647
它有一个对偶性

206
00:16:28,159 --> 00:16:30,975
比方说这个minimize这个呢

207
00:16:31,231 --> 00:16:34,303
就相当于它这个对偶

208
00:16:35,839 --> 00:16:37,631
Maximize这个

209
00:16:37,887 --> 00:16:39,167
Maximize

210
00:16:41,215 --> 00:16:47,103
刚才说这个标准的

211
00:16:50,175 --> 00:16:55,807
标准的这个是一个等号，对偶就是这个

212
00:16:58,111 --> 00:16:58,879
这个吧

213
00:16:59,391 --> 00:17:04,767
它有些时候它这个有些时候也会写成这个样子

214
00:17:08,863 --> 00:17:15,007
就是以这个作为标准的话，因为以前的人可能

215
00:17:15,263 --> 00:17:17,055
都有两种，

216
00:17:17,311 --> 00:17:22,687
两种都有，如果是一种的话呢，那它这个对偶就是

217
00:17:23,967 --> 00:17:27,551
有一点点不一样，其实两个是可以

218
00:17:28,575 --> 00:17:32,671
因为它们是互通的嘛，所以这些都是

219
00:17:33,183 --> 00:17:34,975
等价的

220
00:17:44,959 --> 00:17:47,519
有些时候

221
00:17:47,775 --> 00:17:49,311
你解这个

222
00:17:50,591 --> 00:17:54,687
有些时候你解这个是方便

223
00:17:54,943 --> 00:17:58,015
看哪一个方便一点，其实那就

224
00:17:58,271 --> 00:18:01,855
有些时候它这个primal的problem

225
00:18:02,111 --> 00:18:03,647
这个

226
00:18:07,231 --> 00:18:11,071
看你哪一个variables少一点

227
00:18:12,607 --> 00:18:16,191
可能这个x有很多，可能它这个对偶

228
00:18:16,447 --> 00:18:20,543
反而容易解的话呢，你可以先把它变成一个对偶

229
00:18:21,567 --> 00:18:25,919
解完之后你可以拿到这个primal

230
00:18:29,247 --> 00:18:32,063
或是说有些算法就

231
00:18:32,831 --> 00:18:38,207
两个一起用，利用这个叫primal-dual的alogorithm

232
00:18:42,303 --> 00:18:44,351
两边一起解

233
00:18:56,127 --> 00:18:59,199
nonlinear的话就

234
00:19:03,807 --> 00:19:04,831
它这个

235
00:19:05,855 --> 00:19:11,487
是以前的，有一些nonlinear的问题

236
00:19:11,999 --> 00:19:13,535
非常困难的

237
00:19:14,047 --> 00:19:15,071
非常难

238
00:19:17,887 --> 00:19:23,775
但如果它是凸的话呢，就还是容易解

239
00:19:25,823 --> 00:19:31,455
然后这个是一个经典的一个一般我们叫

240
00:19:31,967 --> 00:19:38,111
KKT condition，不过我不太管这个就是说给你

241
00:19:38,367 --> 00:19:42,975
任意的一个nonlinear programming

242
00:19:43,999 --> 00:19:48,351
现在objective function是nonlinear的

243
00:19:48,607 --> 00:19:49,887
这个是nonlinear

244
00:19:53,471 --> 00:19:56,287
然后呢它这个呢

245
00:19:58,591 --> 00:20:00,639
有一个

246
00:20:02,687 --> 00:20:06,271
最优解的一个

247
00:20:06,527 --> 00:20:08,831
条件，就是这种

248
00:20:26,495 --> 00:20:32,639
nonlinear呢，但是如果这个，如果

249
00:20:32,895 --> 00:20:36,735
这个nonlinear的问题它这个

250
00:20:37,247 --> 00:20:39,295
是Convex的话呢

251
00:20:47,487 --> 00:20:52,351
Convex的条件，什么叫convex呢

252
00:20:52,607 --> 00:20:55,679
本来以前的话呢我就

253
00:20:55,935 --> 00:20:59,775
可以在白板上面画一些图，因为我

254
00:21:01,055 --> 00:21:04,127
通常我比较偷懒，我就

255
00:21:04,383 --> 00:21:05,663
不画图的

256
00:21:07,199 --> 00:21:10,271
通常？？

257
00:21:10,527 --> 00:21:16,672
课堂上面我就直接在这个白板上面就会画一些图

258
00:21:17,184 --> 00:21:23,328
但现在没办法那我就...但是你Google一下那你就可以

259
00:21:25,376 --> 00:21:28,704
搜到很多图的其实

260
00:21:32,288 --> 00:21:34,848
顺便说一下那就是

261
00:21:35,104 --> 00:21:38,944
以前有一些学生他就说我这些

262
00:21:42,784 --> 00:21:44,576
教材

263
00:21:46,112 --> 00:21:50,976
字比较少，他说这个字比较少

264
00:21:51,232 --> 00:21:57,376
其实你可以这样子，比方说你想知道

265
00:21:57,632 --> 00:22:01,472
多一点这个关于这个的话呢

266
00:22:03,008 --> 00:22:07,104
你可以自己再用Google去搜一下

267
00:22:08,384 --> 00:22:12,224
我这个课件就

268
00:22:13,248 --> 00:22:15,552
写很多关键词

269
00:22:16,064 --> 00:22:20,672
我把一些认为是关键的词我就写上去了

270
00:22:21,184 --> 00:22:24,512
然后呢其实你可以用这个

271
00:22:24,768 --> 00:22:27,328
Google

272
00:22:28,096 --> 00:22:31,424
你就会发现很多的了，我把这个

273
00:22:31,936 --> 00:22:36,032
关键词写出来其实我觉得已经足够了

274
00:22:37,568 --> 00:22:42,432
或是说把一些最关键的概念讲出来就可以

275
00:22:43,968 --> 00:22:50,112
你看这个是一个凸的集，或者是

276
00:22:51,392 --> 00:22:55,488
这个就不是，它的定义其实很简单

277
00:22:55,744 --> 00:22:57,024
它原来的定义就是

278
00:22:57,280 --> 00:22:58,816
我给你

279
00:23:01,120 --> 00:23:04,448
这个集上面如果我给你任意的两个点

280
00:23:04,704 --> 00:23:06,752
然后你连一根线

281
00:23:07,008 --> 00:23:13,152
在这根线的上面，是这种情况的话呢，这个线

282
00:23:13,408 --> 00:23:16,480
上面所有的点都是在这个

283
00:23:18,016 --> 00:23:20,320
凸的集上面

284
00:23:22,112 --> 00:23:24,160
但是如果是非凸的集

285
00:23:25,952 --> 00:23:32,096
你可以看到它可能在中间那个过程当中，有一些就跑离开，不在

286
00:23:32,352 --> 00:23:32,864
这个

287
00:23:33,120 --> 00:23:39,264
不在这个集上面的，这个集就不是凸了。这个也不是

288
00:23:40,800 --> 00:23:45,408
这个就是了，因为你上面任意给两个点呢

289
00:23:45,920 --> 00:23:46,688
都....

290
00:23:47,456 --> 00:23:51,808
它经过的这些点那上面的这些点

291
00:23:52,320 --> 00:23:53,856
都是在这个集里面

292
00:23:58,720 --> 00:24:04,864
所以如果你是用这种什么内点法，这种情况就

293
00:24:05,120 --> 00:24:06,656
比较难的，因为

294
00:24:06,912 --> 00:24:10,496
比方说你做这个line search的话呢

295
00:24:11,776 --> 00:24:17,920
其实检查它是不是已经超过这个boundary这个在外边

296
00:24:19,456 --> 00:24:25,088
假定这个是在可行域的话呢，那你在这个可行域外边

297
00:24:26,112 --> 00:24:30,208
就不是答案了

298
00:24:30,720 --> 00:24:35,072
但是如果你这个在里边的话呢

299
00:24:36,352 --> 00:24:42,496
你这个line search就不需要做这个检查了，它保证一定是在这个

300
00:24:42,752 --> 00:24:44,544
可行域的里边

301
00:24:45,312 --> 00:24:47,872
所以就是

302
00:24:48,640 --> 00:24:50,176
凸优化就是

303
00:24:50,688 --> 00:24:52,736
可以有一个

304
00:24:52,992 --> 00:24:55,296
比较简单的做法

305
00:24:56,576 --> 00:24:59,904
而且另外一个就是它这个local minimum

306
00:25:00,160 --> 00:25:02,976
就是等于它这个global minimum

307
00:25:05,536 --> 00:25:09,376
这什么意思呢？就再找一个图

308
00:25:18,336 --> 00:25:20,640
找这个

309
00:25:23,456 --> 00:25:25,504
这个是一个

310
00:25:25,760 --> 00:25:27,296
凸函数

311
00:25:27,808 --> 00:25:29,088
凸函数

312
00:25:31,648 --> 00:25:37,024
然后呢它这个minimum的地方，最小的这个，

313
00:25:39,072 --> 00:25:40,864
就是locally最小，

314
00:25:41,120 --> 00:25:45,216
就是它这个globally也是最小

315
00:25:46,240 --> 00:25:47,776
因为如果不是的话呢

316
00:25:51,360 --> 00:25:56,480
不是一个凸函数的话呢，它有可能你找到的这个是一个

317
00:25:56,736 --> 00:25:58,784
因为你这个算法可能

318
00:25:59,040 --> 00:26:02,624
只能够找到它这个local的minimum

319
00:26:03,904 --> 00:26:07,744
可能就停在这里了，它找到一个最小的时候，

320
00:26:08,256 --> 00:26:14,400
locally最小的话它有可能就停在这里，然后它不会去找，可能最小

321
00:26:14,656 --> 00:26:15,424
在这里

322
00:26:16,192 --> 00:26:17,472
但是因为它

323
00:26:17,728 --> 00:26:22,336
这个不是凸的，所以它就会停在这里

324
00:26:24,640 --> 00:26:28,992
有可能只找到local minimum，这就是为什么这个

325
00:26:31,552 --> 00:26:33,856
凸这个就很重要，

326
00:26:34,624 --> 00:26:38,208
所以

327
00:26:38,464 --> 00:26:42,304
过去10年呢

328
00:26:42,560 --> 00:26:45,632
就有很多人都研究这个

329
00:26:45,888 --> 00:26:48,448
凸优化的

330
00:26:56,128 --> 00:26:59,968
它有趣的地方呢就是

331
00:27:00,992 --> 00:27:04,320
有些问题，它表面上

332
00:27:05,344 --> 00:27:08,416
看起来它不是凸的问题

333
00:27:08,672 --> 00:27:13,024
给你的时候，人家给你一个问题的时候，

334
00:27:13,280 --> 00:27:14,304
它

335
00:27:14,816 --> 00:27:20,960
表面上看起来好像不是，但有些时候呢你经过一个

336
00:27:21,216 --> 00:27:23,520
transformation之后

337
00:27:24,800 --> 00:27:29,408
它有可能就会变成一个凸的问题

338
00:27:29,920 --> 00:27:36,064
那就是把原来一个看起来很难解决的问题，现在就变成

339
00:27:36,320 --> 00:27:42,464
比较容易解决了。所以它这个有趣的地方，就是

340
00:27:42,720 --> 00:27:44,000
在这里

341
00:27:44,768 --> 00:27:49,376
所以过去有很多人研究这个

342
00:27:53,216 --> 00:27:57,568
然后如果给你任意的一个

343
00:27:59,104 --> 00:28:02,944
非线性的规划的问题，

344
00:28:06,784 --> 00:28:12,928
它不一定是凸的，但是它这个对偶的问题，

345
00:28:14,976 --> 00:28:21,120
对偶的问题，这个是它对偶的问题，这个叫

346
00:28:21,376 --> 00:28:24,448
Lagrange duality

347
00:28:30,592 --> 00:28:36,224
这个叫Lagrange multiplier，不过我

348
00:28:36,480 --> 00:28:41,600
不详细说，总之它这个对偶

349
00:28:42,880 --> 00:28:45,696
一定是Convex

350
00:28:46,720 --> 00:28:50,560
就是说这个可能是

351
00:28:50,816 --> 00:28:52,352
看原来那个问题，

352
00:28:53,120 --> 00:28:56,192
原来的问题可能就

353
00:28:56,448 --> 00:28:57,728
很难解

354
00:28:59,520 --> 00:29:03,360
但是它这个对偶的问题呢

355
00:29:06,432 --> 00:29:11,552
其实就一定是一个凸的问题，凸的问题就

356
00:29:12,064 --> 00:29:14,112
比较容易解嘛

357
00:29:15,136 --> 00:29:21,280
那你解它这个对偶的问题，它跟这个linear不一样的

358
00:29:22,560 --> 00:29:24,608
它中间有一个gap

359
00:29:26,400 --> 00:29:32,544
所以你找到的可能只是它这个lower bound或upper bound

360
00:29:34,336 --> 00:29:39,712
如果是minimization problem的话呢，那这个就是它那个

361
00:29:41,248 --> 00:29:42,784
lower bound

362
00:29:45,856 --> 00:29:52,000
但是如果这个原来就有问题它也是

363
00:29:52,256 --> 00:29:53,280
一个

364
00:29:53,536 --> 00:29:55,328
Convex的问题的话呢

365
00:29:56,864 --> 00:29:59,168
那它这个对偶的问题

366
00:29:59,680 --> 00:30:03,520
你找到这个对偶的问题就....

367
00:30:04,288 --> 00:30:07,872
它这个gap就是没有的，所以

368
00:30:10,176 --> 00:30:16,320
你找到它对偶的问题，其实

369
00:30:16,576 --> 00:30:17,856
就算当于

370
00:30:18,112 --> 00:30:20,416
找到它的primal的问题

371
00:30:24,000 --> 00:30:30,144
这个是一个笼统的说法，因为有些时候可能还有看一些条件

372
00:30:30,400 --> 00:30:32,704
有可能就是

373
00:30:36,800 --> 00:30:41,408
有些条件的，不过现在不说那个

374
00:30:47,040 --> 00:30:50,368
另外就是

375
00:30:52,672 --> 00:30:58,816
没有约束条件的这个方法，没有约束条件就是说

376
00:30:59,072 --> 00:31:05,216
我这个问题，其实完全就是纯粹就是minimum这个

377
00:31:07,264 --> 00:31:08,288
function

378
00:31:08,544 --> 00:31:11,616
就没有这个了，没有这个部分

379
00:31:11,872 --> 00:31:14,432
这样子那就当然简单一点，

380
00:31:17,248 --> 00:31:19,808
然后这个方法就有

381
00:31:20,064 --> 00:31:23,392
很多的，我列了一些出来

382
00:31:26,720 --> 00:31:31,840
Line search，line search的方法

383
00:31:32,352 --> 00:31:34,656
只能针对一维

384
00:31:39,008 --> 00:31:43,360
总之就是一些searching的方法

385
00:31:43,616 --> 00:31:44,640
？？

386
00:31:44,896 --> 00:31:50,528
这个我也不是很清楚，golden section应该也是一个搜索的方法

387
00:31:53,856 --> 00:31:58,976
然后这个是梯度的方法，梯度的方法

388
00:32:02,048 --> 00:32:08,192
其实这几类都可以归纳成一类的

389
00:32:08,448 --> 00:32:10,240
这个

390
00:32:10,496 --> 00:32:13,312
它这个梯度来

391
00:32:15,360 --> 00:32:16,896
寻找一个最小

392
00:32:26,880 --> 00:32:29,440
然后这个

393
00:32:29,696 --> 00:32:32,768
你可以笼统的就是把这个

394
00:32:35,328 --> 00:32:39,936
看成是一个下降法

395
00:32:44,800 --> 00:32:48,384
这个呢其实是怎么做呢？

396
00:32:50,432 --> 00:32:51,456
你

397
00:32:51,712 --> 00:32:56,064
先定一个初始的答案

398
00:32:57,344 --> 00:33:03,488
然后你就定一个下降的一个方向

399
00:33:05,792 --> 00:33:07,328
先定一个方向

400
00:33:08,864 --> 00:33:11,680
这个方向叫P

401
00:33:13,216 --> 00:33:16,544
即使你定了一个方向之后，

402
00:33:18,080 --> 00:33:22,432
就等于把一个多维的问题，现在就

403
00:33:22,688 --> 00:33:26,528
变成一个一维的问题了，因为之后你就

404
00:33:27,552 --> 00:33:29,344
沿着这个

405
00:33:30,112 --> 00:33:32,928
P这个方向去寻找

406
00:33:36,768 --> 00:33:42,912
那你就可以用一些一维的方法了，一维的方法有什么呢？line search，这个什么。

407
00:33:45,216 --> 00:33:51,360
然后呢在这根线上面，那就找找找找找，找到某一个吧

408
00:33:52,896 --> 00:33:53,920
就可以确定

409
00:33:54,176 --> 00:33:55,968
它的

410
00:33:57,504 --> 00:33:59,552
Step size

411
00:34:00,064 --> 00:34:01,088
走多远，

412
00:34:03,136 --> 00:34:08,000
然后你就走过去了，把这个x更新，沿着那个方向

413
00:34:08,256 --> 00:34:09,792
更新那个x

414
00:34:10,816 --> 00:34:15,168
找到了方向之后....你找到一个新的X之后

415
00:34:15,680 --> 00:34:21,824
然后呢你又重复了，再定下一个

416
00:34:22,080 --> 00:34:25,920
方向，再定下一个方向

417
00:34:26,176 --> 00:34:28,480
直至

418
00:34:28,736 --> 00:34:31,296
这个step size变得很小

419
00:34:31,808 --> 00:34:33,600
有一个stopping criteria

420
00:34:34,112 --> 00:34:37,952
或是说，之前那个跟之后那个

421
00:34:38,464 --> 00:34:43,840
差别不是很大了，你就找到一个local的

422
00:34:44,096 --> 00:34:46,144
minimum

423
00:34:57,408 --> 00:35:01,248
其实基本上很多优化的算法

424
00:35:02,016 --> 00:35:07,392
就离不开两种罢了，这个是其中一种

425
00:35:08,928 --> 00:35:10,976
另外一种，

426
00:35:12,000 --> 00:35:17,120
之后有一节课我会讲关于椭球法

427
00:35:17,888 --> 00:35:20,448
的时候....它是另外一种

428
00:35:22,496 --> 00:35:26,336
然后呢如果你说这个linear programming的话呢

429
00:35:27,872 --> 00:35:33,504
其实你这个simplex method你也可以看成是一个下降法

430
00:35:34,272 --> 00:35:37,600
只不过linear programming的时候呢

431
00:35:38,112 --> 00:35:41,952
它永远它定的那个方向

432
00:35:43,488 --> 00:35:47,584
它一定是沿着这个函数的

433
00:35:50,144 --> 00:35:53,216
这个边

434
00:35:53,472 --> 00:35:59,616
它这个feasible region的这个边，因为它是linear的嘛

435
00:35:59,872 --> 00:36:02,944
所以沿着它的这个边来走，每一次都是

436
00:36:03,200 --> 00:36:04,992
然后下降

437
00:36:06,016 --> 00:36:10,112
每一次都可以走到一个它那个

438
00:36:12,160 --> 00:36:15,744
走到最低的这个的，每次都可以，

439
00:36:23,936 --> 00:36:24,704
然后

440
00:36:25,728 --> 00:36:27,520
一般的

441
00:36:27,776 --> 00:36:31,616
怎么定下降的方向？

442
00:36:32,640 --> 00:36:38,784
最简单的话呢就是按梯度的这个

443
00:36:39,552 --> 00:36:41,344
反方向，对吧

444
00:36:44,672 --> 00:36:48,256
因为要往下走

445
00:36:48,512 --> 00:36:52,608
其中一种最简单的就是这种做法了

446
00:36:53,632 --> 00:36:59,776
另外有一种叫steepest descent，你往下

447
00:37:00,032 --> 00:37:01,312
走的话呢

448
00:37:01,824 --> 00:37:05,920
但是你是希望往

449
00:37:06,176 --> 00:37:07,968
最斜的方向

450
00:37:15,904 --> 00:37:21,792
所以你就？？这个，但是你要minimize的话呢就

451
00:37:23,328 --> 00:37:29,472
就要看这个问题本身，如果你能够很容易就找到这个的话呢

452
00:37:32,544 --> 00:37:34,336
你就用这个

453
00:37:34,592 --> 00:37:36,128
steepest descent

454
00:37:42,784 --> 00:37:47,904
这个是另外一个优化的问题，但是你如果你有办法可以

455
00:37:48,160 --> 00:37:50,720
很容易就找到的话呢你就用那个

456
00:37:52,768 --> 00:37:55,840
然后呢就哦

457
00:38:04,800 --> 00:38:09,408
这个呢有些时候那你就

458
00:38:13,760 --> 00:38:15,808
这个是un-normalized

459
00:38:17,088 --> 00:38:18,112
然后那就

460
00:38:18,880 --> 00:38:19,904
这个

461
00:38:20,672 --> 00:38:24,512
这个只是我不知道了，但是

462
00:38:30,400 --> 00:38:32,192
这个作为一个

463
00:38:33,472 --> 00:38:39,616
什么

464
00:38:43,712 --> 00:38:49,856
然后我们比较熟悉的这是牛顿法，它基本上

465
00:38:51,136 --> 00:38:52,416
它先定这个

466
00:38:55,488 --> 00:38:58,560
牛顿法的话呢

467
00:38:58,816 --> 00:39:04,960
有些时候有些函数可能比这个更快一点

468
00:39:05,216 --> 00:39:09,824
所以牛顿法也是常用的一种方法

469
00:39:10,080 --> 00:39:16,224
然后呢有一种就是

470
00:39:16,480 --> 00:39:18,272
针对这个

471
00:39:22,880 --> 00:39:29,024
这个conjugate gradient主要是针对

472
00:39:31,072 --> 00:39:34,400
quadratic的问题的，二次的问题

473
00:39:40,032 --> 00:39:42,336
然后呢你记得如果这个有一个

474
00:39:42,848 --> 00:39:48,224
一边那如果有一个哦这个矩阵A

475
00:39:49,504 --> 00:39:51,552
如果它是正定的话呢

476
00:39:55,136 --> 00:39:59,744
它是正定的话呢你就可以定义一个叫

477
00:40:03,072 --> 00:40:06,912
正交的一个有一个定义的

478
00:40:16,896 --> 00:40:22,528
一般来说给你任何一个

479
00:40:27,136 --> 00:40:33,280
二次的问题，或是任何一个问题，优化有一个目标

480
00:40:33,536 --> 00:40:34,304
函数

481
00:40:36,608 --> 00:40:41,984
你很难做到这个呢就是说p

482
00:40:42,240 --> 00:40:44,544
跟之前的这个方向

483
00:40:44,800 --> 00:40:47,360
正交所有方向

484
00:40:48,128 --> 00:40:52,736
为什么要这样做，因为就是有些时候你就避免。我这个，

485
00:40:53,248 --> 00:40:59,392
我这次沿着这个梯度走，可能就从这边走到另外一边，

486
00:41:00,160 --> 00:41:06,304
走到这边之后呢，结果它下一次它这个最小的

487
00:41:06,560 --> 00:41:12,704
梯度就走回去，这个就是走回去，走回去

488
00:41:12,960 --> 00:41:19,104
走回去那这个improvement就很小变成，这个来来回回的这样走

489
00:41:19,360 --> 00:41:25,504
来来来回回的走呀走得很慢了才能够走到这个最底的这个地方

490
00:41:27,296 --> 00:41:33,440
所以它有些时候就希望这个了，之前走过的方向呢

491
00:41:33,696 --> 00:41:35,232
我就

492
00:41:35,488 --> 00:41:37,024
不要走了对吧

493
00:41:39,072 --> 00:41:42,912
那最好就是正交的方向，

494
00:41:43,424 --> 00:41:47,264
那你要记住所有之前的方向的话呢

495
00:41:47,520 --> 00:41:49,568
那你这个就，

496
00:41:50,592 --> 00:41:52,640
很花

497
00:41:53,919 --> 00:41:58,783
内存

498
00:41:59,039 --> 00:42:05,183
但是如果你这个问题的是你的A这个矩阵，它是

499
00:42:05,439 --> 00:42:06,975
正定的话呢

500
00:42:07,743 --> 00:42:10,559
那你可以定义另外一个

501
00:42:12,095 --> 00:42:14,655
正交的一个

502
00:42:15,167 --> 00:42:21,311
它可以就你不需要记住之前的这个

503
00:42:22,335 --> 00:42:23,359
方向

504
00:42:24,639 --> 00:42:27,711
我就可以找到一个什么的

505
00:42:27,967 --> 00:42:33,343
需要跟之前这个，我记住之前这个就可以了

506
00:42:37,183 --> 00:42:42,815
这种特殊的情况。所以如果你现在这个优化的问题，

507
00:42:43,071 --> 00:42:45,119
它是一个二次的问题

508
00:42:46,655 --> 00:42:47,935
quadratic

509
00:42:48,447 --> 00:42:52,543
而且它这个A

510
00:42:52,799 --> 00:42:54,079
是

511
00:42:55,615 --> 00:42:56,895
正定的话呢

512
00:43:00,223 --> 00:43:06,367
其实你用这个conjugate gradient的话，就

513
00:43:06,623 --> 00:43:12,767
是最快的了

514
00:43:15,327 --> 00:43:16,863
所以这个方法很有名，

515
00:43:19,167 --> 00:43:25,311
另外一些比方说这个，最近很多人都

516
00:43:25,567 --> 00:43:27,359
讨论的这种方法

517
00:43:27,615 --> 00:43:30,431
stochastic subgradient

518
00:43:37,855 --> 00:43:43,999
就是有些时候因为，如果你做DFM的话，有些

519
00:43:44,255 --> 00:43:50,399
利用这个统计的方法，因为你有一些

520
00:43:50,655 --> 00:43:52,959
processs variation

521
00:43:53,215 --> 00:43:56,799
在第1节课的时候

522
00:43:57,567 --> 00:44:03,711
现在有很多不确定的，会产生一些随机的变动

523
00:44:03,967 --> 00:44:08,319
所以如果你用一些统计的方法

524
00:44:08,831 --> 00:44:13,695
统计的方法但是你就凭这个

525
00:44:17,023 --> 00:44:19,071
凭一些

526
00:44:19,583 --> 00:44:22,655
Sample的data

527
00:44:23,167 --> 00:44:29,311
采样，采样的数据嘛，采样的数据的话呢，但是如果你

528
00:44:29,567 --> 00:44:32,895
这个采样的数据太多

529
00:44:33,919 --> 00:44:39,807
那你计算就很慢

530
00:44:40,319 --> 00:44:46,463
所以其中一种方法就是我就不用所有的数据，

531
00:44:46,719 --> 00:44:52,863
我可能就选某一些，每一次我只是选

532
00:44:53,119 --> 00:44:58,495
一些采样，采样某一些

533
00:44:59,519 --> 00:45:04,383
作为我这个方向

534
00:45:08,735 --> 00:45:14,879
然后呢有一种就是

535
00:45:16,927 --> 00:45:22,559
网络流的问题了，网络流的问题的话呢

536
00:45:22,815 --> 00:45:28,959
其实你也可以把它看成是一个

537
00:45:29,215 --> 00:45:30,239
下降法

538
00:45:33,055 --> 00:45:39,199
网络流的问题它定的这个方向呢其实是从

539
00:45:39,455 --> 00:45:40,479
一个叫，

540
00:45:40,735 --> 00:45:42,015
Negative cycle

541
00:45:43,039 --> 00:45:44,063
来确定的

542
00:45:45,343 --> 00:45:47,391
这个后边可能

543
00:45:48,159 --> 00:45:50,719
以后会再说

544
00:45:51,743 --> 00:45:55,839
网络流的问题有一个特点就是说

545
00:45:56,607 --> 00:45:59,423
它不单单是对这个

546
00:46:00,959 --> 00:46:04,799
Continuous的问题

547
00:46:05,055 --> 00:46:05,823
有用

548
00:46:07,103 --> 00:46:12,991
而且它可以对一些离散的问题也可以

549
00:46:14,015 --> 00:46:16,575
用这个方法来

550
00:46:17,087 --> 00:46:18,367
解决的

551
00:46:19,391 --> 00:46:22,975
所以一个离散的问题

552
00:46:23,743 --> 00:46:25,279
它表面上可能

553
00:46:25,791 --> 00:46:30,911
看起来好像是一个很难的问题np-hard问题

554
00:46:31,935 --> 00:46:35,007
但是如果你能够把它

555
00:46:35,263 --> 00:46:39,871
用网络流表示出来的话呢

556
00:46:40,895 --> 00:46:44,479
那就说明这个问题它其实

557
00:46:44,735 --> 00:46:46,527
并不是一个

558
00:46:47,551 --> 00:46:50,623
Np-hard问题了

559
00:46:51,391 --> 00:46:53,695
比方说一些

560
00:46:53,951 --> 00:46:56,767
matching的问题，配对的问题

561
00:46:58,559 --> 00:47:02,655
有些时候呢就是用

562
00:47:03,423 --> 00:47:06,751
网络流的方法可以解决

563
00:47:10,079 --> 00:47:15,967
然后有约束条件跟没有约束条件呢就有些时候

564
00:47:19,295 --> 00:47:24,159
其实跟之前这个做法差不多只不过就是

565
00:47:24,415 --> 00:47:25,951
这个cost function

566
00:47:26,719 --> 00:47:29,023
目标函数，其实它就

567
00:47:29,279 --> 00:47:32,863
多了一些。多加一个叫

568
00:47:33,631 --> 00:47:36,191
penalization

569
00:47:37,727 --> 00:47:39,519
或是叫 barrier

570
00:47:39,775 --> 00:47:42,847
就是在这个可行域的

571
00:47:43,359 --> 00:47:44,895
边界上面呢

572
00:47:45,407 --> 00:47:51,039
加一个惩罚的一个，就是它这个惩罚就很高

573
00:47:52,831 --> 00:47:54,623
使到你这个

574
00:47:56,415 --> 00:47:57,951
你这个

575
00:47:58,207 --> 00:48:04,351
下降法的时候，做这个的时候那你就不会走到边界上边去

576
00:48:07,167 --> 00:48:13,311
然后有一个dual对偶的方法，对偶的方法就是这些时候你

577
00:48:13,567 --> 00:48:15,615
这个

578
00:48:16,639 --> 00:48:19,711
primal的这个太难了

579
00:48:21,247 --> 00:48:25,855
其实这个内点法跟这个第一个是差不多的

580
00:48:27,391 --> 00:48:28,927
内点法的方法

581
00:48:30,207 --> 00:48:36,351
然后这个不是很清楚，这个可能是用在一些特殊的问题

582
00:48:36,607 --> 00:48:37,887
上面的

583
00:48:40,703 --> 00:48:44,287
然后这个书

584
00:48:45,823 --> 00:48:50,687
这个springer里面可以找到

585
00:48:50,943 --> 00:48:54,015
所以你自己可以下载的

586
00:48:55,039 --> 00:48:57,343
如果在学校的话可以下载

587
00:48:58,623 --> 00:49:04,767
这个的话呢，图书馆应该有，但是它不是springer的所以

588
00:49:05,023 --> 00:49:09,375
该走什么，不过这个好像有电子版的，我曾经见过

589
00:49:10,399 --> 00:49:11,935
有电子版可以下载

590
00:49:12,447 --> 00:49:18,335
这个人呢这个很有名的他是史丹福大学的教授

591
00:49:19,103 --> 00:49:25,247
然后他有一些课的，其实有些课在网上可以看到的

592
00:49:28,319 --> 00:49:32,671
然后这个的话呢就

593
00:49:33,695 --> 00:49:38,815
因为这些优化的软件有很多所以

594
00:49:40,095 --> 00:49:45,215
哪一些问题用哪一个算法哪一个软件包，你可以

595
00:49:45,471 --> 00:49:47,263
在这个地方可以可以看到
