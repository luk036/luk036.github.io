<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Wai-Shing Luk" />
  <meta name="date" content="2015-10-20" />
  <title>Ellipsoid method Revisited</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Ellipsoid method Revisited</h1>
  <p class="author">
Wai-Shing Luk
  </p>
  <p class="date">2015-10-20</p>
</div>
<div id="basic-ellipsoid-method" class="slide section level2">
<h1>Basic Ellipsoid Method</h1>
<ul>
<li>An ellipsoid <span class="math inline">‚Ñ∞(<em>x</em><sub><em>c</em></sub>,‚ÄÜ<em>P</em>)</span> is specified as a set <br /><span class="math display">{<em>x</em>‚ÄÖ‚à£‚ÄÖ(<em>x</em>‚ÄÖ‚àí‚ÄÖ<em>x</em><sub><em>c</em></sub>)<em>P</em><sup>‚àí1</sup>(<em>x</em>‚ÄÖ‚àí‚ÄÖ<em>x</em><sub><em>c</em></sub>)‚â§1},</span><br /> where <span class="math inline"><em>x</em><sub><em>c</em></sub></span> is the center of the ellipsoid.</li>
</ul>

</div>
<div id="matlab-code" class="slide section level2 allowframebreaks">
<h1>Matlab code</h1>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">classdef ell &lt; handle
  <span class="co">% ell = { x | (x - xc)&#39; * P^-1 * (x - xc) &lt;= 1 }</span>
  properties
    P, xc, c1
  end    
  methods
    function obj = ell(val, x)
      n = length(x);
      if isscalar(val), 
        obj.P = diag(val*ones(n,<span class="fl">1</span>));
      else isvector(val),
        obj.P = diag(val);
      end
      obj.xc = x;
      obj.c1 = n*n/(n*n-<span class="fl">1</span>);
    end
                
    function [status,rho,sigma,delta] = calc_dc(obj,alpha) [...]
    function [status,rho,sigma,delta] = calc_ll(obj,alpha) [...]
    function [status,tau] = update_core(obj,calc,g,beta) [...]
  end
end</code></pre></div>
</div>
<div id="updating-the-ellipsoid-deep-cut" class="slide section level2">
<h1>Updating the ellipsoid (deep-cut)</h1>
<ul>
<li>Calculation of minimum volume ellipsoid covering: <br /><span class="math display">‚Ñ∞‚ÄÖ‚à©‚ÄÖ{<em>z</em>‚ÄÖ‚à£‚ÄÖ<em>g</em><sup><em>T</em></sup>(<em>z</em>‚ÄÖ‚àí‚ÄÖ<em>x</em><sub><em>c</em></sub>)+<em>h</em>‚ÄÑ‚â§‚ÄÑ0}</span><br /></li>
<li>Let <span class="math inline">$\tilde{g} = P\,g$</span>, <span class="math inline">$\tau = \sqrt{g^\top\tilde{g}}$</span>, <span class="math inline"><em>Œ±</em>‚ÄÑ=‚ÄÑ<em>h</em>/<em>œÑ</em></span>.</li>
<li>If <span class="math inline"><em>Œ±</em>‚ÄÑ&gt;‚ÄÑ1</span>, intersection is empty.</li>
<li>If <span class="math inline"><em>Œ±</em>‚ÄÑ&lt;‚ÄÑ‚àí1/<em>n</em></span> (shallow cut), no smaller ellipsoid can be found.</li>
<li>Otherwise, <br /><span class="math display">$$\begin{array}{lll}
 x_c^+ &amp;=&amp; x_c - \frac{1+n\alpha}{(n+1)\tau} \tilde{g}  \\
 P^+ &amp;=&amp; \frac{n^2(1-\alpha^2)}{n^2 - 1}\left(P - \frac{2\rho}{(1+\alpha)\tau^2} \tilde{g}\tilde{g}^\top\right)
  \end{array}$$</span><br /></li>
</ul>
</div>
<div id="matlab-code-updating" class="slide section level2">
<h1>Matlab code (updating)</h1>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [status, tau] = ...
            update_core(obj, calc_ell, g, beta)
  Pg = obj.P*g;  
  tsq = g&#39;*Pg;
  tau = sqrt(tsq);
  alpha = beta/tau;
  [status, rho, sigma, delta] = calc_ell(alpha);
  if status ~= <span class="fl">0</span>, return; end;
  obj.xc = obj.xc - (rho/tau)*Pg;
  obj.P = delta*(obj.P - (sigma/tsq)*(Pg*Pg&#39;));
  status = <span class="fl">0</span>; <span class="co">% okay</span>
end</code></pre></div>
</div>
<div id="matlab-code-deep-cut" class="slide section level2">
<h1>Matlab code (deep cut)</h1>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [status, rho, sigma, delta] = calc_dc(obj, alpha)
  rho = <span class="fl">0</span>; sigma = <span class="fl">0</span>; delta = <span class="fl">0</span>;
  if alpha &gt; <span class="fl">1</span>, status = <span class="fl">1</span>; return; end; <span class="co">% no sol&#39;n</span>
  n = size(obj.xc,<span class="fl">1</span>);
  if n*alpha &lt; -<span class="fl">1</span>, status = <span class="fl">3</span>; return; end; <span class="co">% no effect</span>
  rho = (<span class="fl">1</span>+n*alpha)/(n+<span class="fl">1</span>);
  sigma = <span class="fl">2</span>*rho/(<span class="fl">1</span>+alpha);
  delta = obj.c1*(<span class="fl">1</span>-alpha*alpha);
  status = <span class="fl">0</span>; <span class="co">% okay</span>
end</code></pre></div>
</div>
<div id="parallel-cuts" class="slide section level2">
<h1>Parallel Cuts</h1>
<ul>
<li>Oracle returns a pair of cuts instead of just one.</li>
<li>The pair of cuts is given by <span class="math inline"><em>g</em></span> and <span class="math inline">(<em>h</em><sub>1</sub>,‚ÄÜ<em>h</em><sub>2</sub>)</span> such that: <br /><span class="math display">$$\begin{split}
g^\top (x - x_c) + h_1 \leq 0,  \\
g^\top (x - x_c) + h_2 \geq 0,
\end{split}$$</span><br /> for all <span class="math inline"><em>x</em>‚ÄÑ‚àà‚ÄÑùí¶</span>.</li>
<li>Only linear inequality constraint can produce such parallel cut: <br /><span class="math display"><em>l</em>‚ÄÑ‚â§‚ÄÑ<em>a</em><sup><em>T</em></sup><em>x</em>‚ÄÖ+‚ÄÖ<em>b</em>‚ÄÑ‚â§‚ÄÑ<em>u</em>,‚ÄÜ‚ÄÅ‚ÄÅ<em>L</em>‚ÄÑ‚âº‚ÄÑ<em>F</em>(<em>x</em>)‚âº<em>U</em></span><br /></li>
<li>Usually provide faster convergence.</li>
</ul>
</div>
<div id="parallel-cut" class="slide section level2">
<h1>Parallel Cut</h1>
<p><embed src="lec06.files/parallel_cut.pdf" /><br />
</p>
</div>
<div id="updating-the-ellipsoid" class="slide section level2">
<h1>Updating the ellipsoid</h1>
<ul>
<li>Let <span class="math inline">$\tilde{g} = P\,g$</span>, <span class="math inline">$\tau = \sqrt{g^\top\tilde{g}}$</span>, <span class="math inline"><em>Œ±</em><sub>1</sub>‚ÄÑ=‚ÄÑ<em>h</em><sub>1</sub>/<em>œÑ</em></span>, <span class="math inline"><em>Œ±</em><sub>2</sub>‚ÄÑ=‚ÄÑ<em>h</em><sub>2</sub>/<em>œÑ</em></span>.</li>
<li>If <span class="math inline"><em>Œ±</em><sub>2</sub>‚ÄÑ&gt;‚ÄÑ1</span>, it reduces to deep-cut with <span class="math inline"><em>Œ±</em>‚ÄÑ=‚ÄÑ<em>Œ±</em><sub>1</sub></span>.</li>
<li>If <span class="math inline"><em>Œ±</em><sub>1</sub>‚ÄÑ&gt;‚ÄÑ<em>Œ±</em><sub>2</sub></span>, intersection is empty.</li>
<li>If <span class="math inline"><em>Œ±</em><sub>1</sub><em>Œ±</em><sub>2</sub>‚ÄÑ&lt;‚ÄÑ‚àí1/<em>n</em></span>, no smaller ellipsoid can be found.</li>
<li>Otherwise, <br /><span class="math display">$$
 x_c^+ = x_c - \frac{\rho}{\tau} \tilde{g}, \qquad
 P^+ = \delta\left(P - \frac{\sigma}{\tau^2} \tilde{g}\tilde{g}^\top\right)
  $$</span><br /> where <br /><span class="math display">$$\begin{array}{lll}
  \xi &amp;=&amp; \sqrt{4(1 - \alpha_1^2)(1 - \alpha_2^2) + n^2(\alpha_2^2 - \alpha_1^2)^2}, \\
  \sigma &amp;=&amp; \frac{1}{n+1}(n + \frac{2}{(\alpha_1 + \alpha_2)^2}(1 - \alpha_1\alpha_2 - \frac{\xi}{2})), \\
  \rho &amp;=&amp; \frac{1}{2}(\alpha_1 + \alpha_2) \sigma \\
  \delta &amp;=&amp; \frac{n^2}{n^2-1} (1 - \frac{1}{2}(\alpha_1^2 + \alpha_2^2 - \frac{\xi}{n}))
  \end{array}$$</span><br /></li>
</ul>
</div>
<div id="matlab-code-parallel-cut" class="slide section level2">
<h1>Matlab code (parallel cut)</h1>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [status, rho, sigma, delta] = calc_ll(obj, alpha)
  <span class="co">% General parallel cut support</span>
  rho = <span class="fl">0</span>; sigma = <span class="fl">0</span>; delta = <span class="fl">0</span>;
  if length(alpha) == <span class="fl">1</span> || alpha(<span class="fl">2</span>) &gt;= <span class="fl">1</span>, <span class="co">% deep cut</span>
      [status, rho, sigma, delta] = calc_dc(obj, alpha(<span class="fl">1</span>));
      return;
  end
  if alpha(<span class="fl">1</span>) &gt; alpha(<span class="fl">2</span>), status = <span class="fl">1</span>; return; end; <span class="co">% no sol&#39;n</span>
  aprod = alpha(<span class="fl">1</span>) * alpha(<span class="fl">2</span>);
  n = size(obj.xc,<span class="fl">1</span>);
  if -n*aprod &gt;= <span class="fl">1</span>, status = <span class="fl">3</span>; return; end; <span class="co">% no effect</span>
  asq = alpha.*alpha; asum = alpha(<span class="fl">1</span>) + alpha(<span class="fl">2</span>);
  xi = sqrt(<span class="fl">4</span>*(<span class="fl">1</span>-asq(<span class="fl">1</span>))*(<span class="fl">1</span>-asq(<span class="fl">2</span>)) + n*n*(asq(<span class="fl">2</span>)-asq(<span class="fl">1</span>))^<span class="fl">2</span>);
  sigma = (n + (<span class="fl">2</span>*(<span class="fl">1</span> + aprod - xi/<span class="fl">2</span>)/asum^<span class="fl">2</span>))/(n+<span class="fl">1</span>);
  rho = asum * sigma/<span class="fl">2</span>;
  delta = obj.c1*(<span class="fl">1</span> - (asq(<span class="fl">1</span>) + asq(<span class="fl">2</span>) - xi/n)/<span class="fl">2</span>);
  status = <span class="fl">0</span>; <span class="co">% okay</span>
end</code></pre></div>
</div>
<div id="example-fir-filter-design" class="slide section level2">
<h1>Example: FIR filter design</h1>
<div class="figure">
<embed src="lec06.files/fir_strctr.pdf" />
<p class="caption">img</p>
</div>
<ul>
<li>The time response is: <br /><span class="math display">$$y[t]~=~\sum_{k=0}^{n-1}{h[k]u[t-k]}$$</span><br /></li>
</ul>
</div>
<div id="example-fir-filter-design-contd" class="slide section level2">
<h1>Example: FIR filter design (cont'd)</h1>
<ul>
<li><p>The frequency response: <br /><span class="math display">$$H(\omega)~=~\sum_{m=0}^{n-1}{h(m)e^{-jm\omega}}$$</span><br /></p></li>
<li><p>The magnitude constraints on frequency domain are expressed as <br /><span class="math display"><em>L</em>(<em>œâ</em>)¬†‚ÄÑ‚â§‚ÄÑ¬†|<em>H</em>(<em>œâ</em>)|¬†‚ÄÑ‚â§‚ÄÑ¬†<em>U</em>(<em>œâ</em>),¬†‚àÄ¬†<em>œâ</em>‚ÄÑ‚àà‚ÄÑ(‚ÄÖ‚àí‚ÄÖ‚àû,‚ÄÜ+‚àû)</span><br /> where <span class="math inline"><em>L</em>(<em>œâ</em>)</span> and <span class="math inline"><em>U</em>(<em>œâ</em>)</span> are the lower and upper (nonnegative) bounds at frequency <span class="math inline"><em>œâ</em></span> respectively.</p></li>
<li><p>The constraint is non-convex in general.</p></li>
</ul>
</div>
<div id="example-fir-filter-design-contd-1" class="slide section level2">
<h1>Example: FIR filter design (cont'd)</h1>
<ul>
<li>However, via <em>spectral factorization</em>, it can transform into a convex one: <br /><span class="math display"><em>L</em><sup>2</sup>(<em>œâ</em>)¬†‚ÄÑ‚â§‚ÄÑ¬†<em>R</em>(<em>œâ</em>)¬†‚ÄÑ‚â§‚ÄÑ¬†<em>U</em><sup>2</sup>(<em>œâ</em>),¬†‚àÄ¬†<em>œâ</em>‚ÄÑ‚àà‚ÄÑ(0,‚ÄÜ<em>œÄ</em>)</span><br /> where
<ul>
<li><span class="math inline">$R(\omega)=\sum_{i=-1+n}^{n-1}{r(t)e^{-j{\omega}t}}=|H(\omega)|^2$</span></li>
<li><span class="math inline"><strong>r</strong>‚ÄÑ=‚ÄÑ(<em>r</em>(‚àí<em>n</em>‚ÄÖ+‚ÄÖ1),<em>r</em>(‚àí<em>n</em>‚ÄÖ+‚ÄÖ2),...,<em>r</em>(<em>n</em>‚ÄÖ‚àí‚ÄÖ1))</span> are the autocorrelation coefficients.</li>
</ul></li>
</ul>
</div>
<div id="example-fir-filter-design-contd-2" class="slide section level2">
<h1>Example: FIR filter design (cont'd)</h1>
<ul>
<li><p><span class="math inline"><strong>r</strong></span> can be determined by <span class="math inline"><strong>h</strong></span>: <br /><span class="math display">$$r(t)~=~\sum_{i=-n+1}^{n-1}{h(i)h(i+t)},~t\in\mathbf{Z}.$$</span><br /> where <span class="math inline"><em>h</em>(<em>t</em>)=0</span> for <span class="math inline"><em>t</em>‚ÄÑ&lt;‚ÄÑ0</span> or <span class="math inline"><em>t</em>‚ÄÑ&gt;‚ÄÑ<em>n</em>‚ÄÖ‚àí‚ÄÖ1</span>.</p></li>
<li><p>The whole problem can be formulated as:</p>
<p><br /><span class="math display">$$\begin{array}{ll}
  \min  &amp; \gamma \\
  \text{s.t.}   &amp; L^2(\omega)~\leq~R(\omega)~\leq~U^2(\omega),~\forall~\omega~\in~[0,\pi]   \\
              &amp; R(\omega)~&gt;~0,~\forall~\omega~\in~[0,\pi] \\
\end{array}$$</span><br /></p></li>
</ul>
</div>
<div id="example-maximum-likelihood-estimation" class="slide section level2">
<h1>Example: Maximum Likelihood estimation</h1>
<p><br /><span class="math display">$$\begin{array}{ll}
      \min_{\kappa, p}   &amp;      \log \det (\Omega(p) + \kappa I) + \mathrm{Tr}((\Omega(p) + \kappa I)^{-1}Y) \\
      \text{s. t.} &amp; \Omega(p) \succeq 0, \kappa \geq 0 \\
\end{array}$$</span><br /></p>
<p>Note: 1st term is concave, 2nd term is convex</p>
<ul>
<li>However, if there is enough samples such that <span class="math inline"><em>Y</em></span> is a positive definite matrix, then the function is convex within <span class="math inline">[0,‚ÄÜ2<em>Y</em>]</span></li>
</ul>
</div>
<div id="example-maximum-likelihood-estimation-contd" class="slide section level2">
<h1>Example: Maximum Likelihood estimation (cont'd)</h1>
<ul>
<li>Therefore, the following problem is convex: <br /><span class="math display">$$\begin{array}{ll}
  \min_{\kappa, p}   &amp;   \log \det V(p) + \mathrm{Tr}(V(p)^{-1}Y) \\
  \text{s. t.} &amp; \Omega(p) + \kappa I = V(p) \\
                &amp; 0 \preceq V(p) \preceq 2Y, \kappa \geq 0 \\
\end{array}$$</span><br /></li>
</ul>
</div>
<div id="discrete-optimization" class="titleslide slide section level1"><h1>Discrete Optimization</h1></div><div id="why-discrete-convex-programming" class="slide section level2">
<h1>Why Discrete Convex Programming</h1>
<ul>
<li><p>Many engineering problems can be formulated as a convex/geometric programming, e.g. digital circuit sizing</p></li>
<li><p>Yet in an ASIC design, often there is only a limited set of choices from the cell library. In other words, some design variables are discrete.</p></li>
<li><p>The discrete version can be formulated as a Mixed-Integer Convex programming (MICP) by mapping the design variables to integers.</p></li>
</ul>
</div><div id="whats-wrong-w-existing-methods" class="slide section level2">
<h1>What‚Äôs Wrong w/ Existing Methods?</h1>
<ul>
<li><p>Mostly based on relaxation.</p></li>
<li><p>Then use the relaxed solution as a lower bound and use the branch‚Äìand‚Äìbound method for the discrete optimal solution.</p>
<ul>
<li>Note: the branch‚Äìand‚Äìbound method does not utilize the convexity of the problem.</li>
</ul></li>
<li><p>What if I can only evaluate constraints on discrete data? Workaround: convex fitting?</p></li>
</ul>
</div><div id="mixed-integer-convex-programming" class="slide section level2">
<h1>Mixed-Integer Convex Programming</h1>
<ul>
<li><p>Consider:</p>
<p><br /><span class="math display">$$\begin{array}{ll}
    \text{minimize}      &amp; f_0(x), \\
    \text{subject to}    &amp; f_j(x) \leq 0, \; \forall j=1,2,\ldots \\
                         &amp; x \in \mathbb{D} 
\end{array}$$</span><br /> where <span class="math inline"><em>f</em><sub>0</sub>(<em>x</em>)</span> and <span class="math inline"><em>f</em><sub><em>j</em></sub>(<em>x</em>)</span> are ‚Äúconvex‚Äù</p></li>
<li><p>Some design variables are discrete.</p></li>
</ul>
</div><div id="oracle-requirement" class="slide section level2">
<h1>Oracle Requirement</h1>
<ul>
<li><p>The oracle looks for the nearby discrete solution <span class="math inline"><em>x</em><sub><em>d</em></sub></span> of <span class="math inline"><em>x</em><sub><em>c</em></sub></span> with the cutting-plane: <br /><span class="math display"><em>g</em><sup><em>T</em></sup>(<em>x</em>‚ÄÖ‚àí‚ÄÖ<em>x</em><sub><em>d</em></sub>)+<em>h</em>‚ÄÑ‚â§‚ÄÑ0,‚ÄÜ<em>h</em>‚ÄÑ‚â•‚ÄÑ0,‚ÄÜ<em>g</em>‚ÄÑ‚â†‚ÄÑ0</span><br /></p></li>
<li>Note: the cut may be a shallow cut.</li>
<li><p>Suggestion: use different cuts as possible for each iteration (e.g. round-robin the evaluation of constraints)</p></li>
</ul>
</div><div id="example-fir-filter-design-1" class="slide section level2">
<h1>Example: FIR filter design</h1>
<p><embed src="lec06.files/lowpass_ripple.pdf" /><br />
</p>
</div>
</body>
</html>
