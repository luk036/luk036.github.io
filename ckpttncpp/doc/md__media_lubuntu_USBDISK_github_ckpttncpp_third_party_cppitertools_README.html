<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>CkPttnCpp: CPPItertools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Roboto:400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Roboto:500' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CkPttnCpp
   &#160;<span id="projectnumber">..</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__media_lubuntu_USBDISK_github_ckpttncpp_third_party_cppitertools_README.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CPPItertools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Range-based for loop add-ons inspired by the Python builtins and itertools library. Like itertools and the Python3 builtins, this library uses lazy evaluation wherever possible.</p>
<p><em>Note</em>: Everything is inside the <code>iter</code> namespace.</p>
<p>Follow <a href="https://twitter.com/cppitertools"></a> for updates.</p>
<h4>Build and Test Status</h4>
<table class="doxtable">
<tr>
<th>Status </th><th>Compilers  </th></tr>
<tr>
<td><a href="https://travis-ci.com/ryanhaining/cppitertools"></a> </td><td>gcc-7 gcc-8 clang-5.0 clang-6.0 </td></tr>
<tr>
<td><a href="https://ci.appveyor.com/project/ryanhaining/cppitertools"></a> </td><td>MSVC 2017 </td></tr>
</table>
<h4>Table of Contents</h4>
<p><a href="#range">range</a><br />
 <a href="#enumerate">enumerate</a><br />
 <a href="#zip">zip</a><br />
 <a href="#zip">zip_longest</a><br />
 <a href="#imap">imap</a><br />
 <a href="#filter">filter</a><br />
 <a href="#filterfalse">filterfalse</a><br />
 <a href="#unique_everseen">unique_everseen</a><br />
 <a href="#unique_justseen">unique_justseen</a><br />
 <a href="#takewhile">takewhile</a><br />
 <a href="#dropwhile">dropwhile</a><br />
 <a href="#cycle">cycle</a><br />
 <a href="#repeat">repeat</a><br />
 <a href="#count">count</a><br />
 <a href="#groupby">groupby</a><br />
 <a href="#starmap">starmap</a><br />
 <a href="#accumulate">accumulate</a><br />
 <a href="#compress">compress</a><br />
 <a href="#sorted">sorted</a><br />
 <a href="#chain">chain</a><br />
 <a href="#chainfrom_iterable">chain.from_iterable</a><br />
 <a href="#reversed">reversed</a><br />
 <a href="#slice">slice</a><br />
 <a href="#sliding_window">sliding_window</a><br />
 <a href="#chunked">chunked</a><br />
</p>
<h5>Combinatoric fuctions</h5>
<p><a href="#product">product</a><br />
 <a href="#combinations">combinations</a><br />
 <a href="#combinations_with_replacement">combinations_with_replacement</a><br />
 <a href="#permutations">permutations</a><br />
 <a href="#powerset">powerset</a><br />
</p>
<h4>Requirements</h4>
<p>This library is <b>header-only</b> and relies only on the C++ standard library. The only exception is <code>zip_longest</code> which uses <code>boost::optional</code>. <code>#include &lt;<a class="el" href="itertools_8hpp.html">cppitertools/itertools.hpp</a>&gt;</code> will include all of the provided tools except for <code>zip_longest</code> which must be included separately. You may also include individual pieces with the relevant header (<code>#include &lt;<a class="el" href="enumerate_8hpp.html">cppitertools/enumerate.hpp</a>&gt;</code> for example).</p>
<h3>Running tests</h3>
<p>You may use either <code>scons</code> or <code>bazel</code> to build the tests. <code>scons</code> seems to work better with viewing the test output, but the same <code>bazel</code> command can be run from any directory.</p>
<p>To run tests with scons you must be within the <code>test</code> directory</p>
<div class="fragment"><div class="line">test$ # build and run all tests</div><div class="line">test$ scons</div><div class="line">test$ ./test_all</div><div class="line">test$ # build and run a specific test</div><div class="line">test$ scons test_enumerate</div><div class="line">test$ ./test_enumerate</div><div class="line">test$ valgrind ./test_enumerate</div></div><!-- fragment --><p><code>bazel</code> absolute commands can be run from any directory inside the project</p>
<div class="fragment"><div class="line">$ bazel test //test:all # runs all tests</div><div class="line">$ bazel test //test:test_enumerate # runs a specific test</div></div><!-- fragment --><h4>Requirements of passed objects</h4>
<p>Most itertools will work with iterables using InputIterators and not copy or move any underlying elements. The itertools that need ForwardIterators or have additional requirements are noted in this document. However, the cases should be fairly obvious: any time an element needs to appear multiple times (as in <code>combinations</code> or <code>cycle</code>) or be looked at more than once (specifically, <code>sorted</code>). This library takes every effort to rely on as little as possible from the underlying iterables, but if anything noteworthy is needed it is described in this document.</p>
<h4>Guarantees of implementations</h4>
<p>By implementations, I mean the objects returned by the API's functions. All of the implementation classes are move-constructible, not copy-constructible, not assignable. All iterators that work over another iterable are tagged as InputIterators and behave as such.</p>
<h4>Feedback</h4>
<p>If you find anything not working as you expect, not compiling when you believe it should, a divergence from the python itertools behavior, or any sort of error, please let me know. The preferable means would be to open an issue on GitHub. If you want to talk about an issue that you don't feel would be appropriate as a GitHub issue (or you just don't want to open one), you can email me directly with whatever code you have that describes the problem; I've been pretty responsive in the past. If I believe you are "misusing" the library, I'll try to put the blame on myself for being unclear in this document and take the steps to clarify it. So please, contact me with any concerns, I'm open to feedback.</p>
<h4>How (not) to use this library</h4>
<p>The library functions create and return objects that are properly templated on the iterable they are passed. These exact names of these types or precisely how they are templated is unspecified, you should rely on the functions described in this document. If you plan to use these functions in very simple, straight forward means as in the examples on this page, then you will be fine. If you feel like you need to open the header files, then I've probably under-described something, let me know.</p>
<h4>Handling of rvalues vs lvalues</h4>
<p>The rules are pretty simple, and the library can be largely used without knowledge of them. Let's take an example </p><div class="fragment"><div class="line">{c++}</div><div class="line">std::vector&lt;int&gt; vec{2,4,6,8};</div><div class="line">for (auto&amp;&amp; p : enumerate(vec)) { /* ... */ }</div></div><!-- fragment --><p> In this case, <code>enumerate</code> will return an object that has bound a reference to <code>vec</code>. No copies are produced here, neither of <code>vec</code> nor of the elements it holds.</p>
<p>If an rvalue was passed to enumerate, binding a reference would be unsafe. Consider: </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto&amp;&amp; p : enumerate(std::vector&lt;int&gt;{2,4,6,8})) { /* ... */ }</div></div><!-- fragment --><p> Instead, <code>enumerate</code> will return an object that has the temporary <em>moved</em> into it. That is, the returned object will contain a <code>std::vector&lt;int&gt;</code> rather than just a reference to one. This may seem like a contrived example, but it matters when <code>enumerate</code> is passed the result of a function call like <code>enumerate(f())</code>, or, more obviously, something like <code>enumerate(zip(a, b))</code>. The object returned from <code>zip</code> must be moved into the <code>enumerate</code> object. As a more specific result, itertools can be mixed and nested.</p>
<h4>Pipe syntax</h4>
<p>Wherever it makes sense, I've implemented the "pipe" operator that has become common in similar libraries. When the syntax is available, it is done by pulling out the iterable from the call and placing it before the tool. For example:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">filter(pred, seq);  // regular call</div><div class="line">seq | filter(pred);  // pipe-style</div><div class="line">enumerate(seq);  // regular call</div><div class="line">seq | enumerate;  // pipe-style.</div></div><!-- fragment --><p>The following tools support pipe. The remaining I left out because although some of them have multiple reasonable versions, it wasn't obvious to me how I would expect them to behave:</p>
<ul>
<li>accumulate</li>
<li>chain.from_iterable</li>
<li>chunked</li>
<li>combinations</li>
<li>combinations_with_replacement</li>
<li>cycle</li>
<li>dropwhile</li>
<li>enumerate</li>
<li>filter</li>
<li>filterfalse</li>
<li>groupby</li>
<li>imap</li>
<li>permutations</li>
<li>powerset</li>
<li>reversed</li>
<li>slice</li>
<li>sliding_window</li>
<li>sorted</li>
<li>starmap</li>
<li>takewhile</li>
<li>unique_everseen</li>
<li>unique_justseen</li>
</ul>
<p>I don't personally care for the piping style, but it seemed to be desired by the users.</p>
<h2>range </h2>
<p>Uses an underlying iterator to achieve the same effect of the python range function. <code>range</code> can be used in three different ways:</p>
<p>Only the stopping point is provided. Prints <code>0 1 2 3 4 5 6 7 8 9</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto i : range(10)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>The start and stop are both provided. Prints <code>10 11 12 13 14</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto i : range(10, 15)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>The start, stop, and step are all provided. Prints <code>20 22 24 26 28</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto i : range(20, 30, 2)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>Negative values are allowed as well. Prints <code>2 1 0 -1 -2</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto i : range(2, -3, -1)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>A step size of 0 results in an empty range (Python's raises an exception). The following prints nothing </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto i : range(0, 10, 0)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>In addition to normal integer range operations, doubles and other numeric types are supported through the template</p>
<p>Prints: <code>5.0 5.5 6.0</code> ... <code>9.5</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">for(auto i : range(5.0, 10.0, 0.5)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p><em>Implementation Note</em>: Typical ranges have their current value incremented by the step size repeatedly (<code>value += step</code>). Floating point range value are recomputed at each step to avoid accumulating floating point inaccuracies (<code>value = start + (step * steps_taken</code>). The result of the latter is a bit slower but more accurate.</p>
<h2>enumerate </h2>
<p>Continually "yields" containers similar to pairs. They are basic structs with a .index and a .element, and also work with structured binding declarations. Usage appears as:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; vec{2, 4, 6, 8};</div><div class="line">for (auto&amp;&amp; [i, e] : enumerate(vec)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; e &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>filter </h2>
<p>Called as <code>filter(predicate, iterable)</code>. The predicate can be any callable. <code>filter</code> will only yield values that are true under the predicate.</p>
<p>Prints values greater than 4: <code>5 6 7 8</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; vec{1, 5, 4, 0, 6, 7, 3, 0, 2, 8, 3, 2, 1};</div><div class="line">for (auto&amp;&amp; i : filter([] (int i) { return i &gt; 4; }, vec)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt;&#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>If no predicate is passed, the elements themselves are tested for truth</p>
<p>Prints only non-zero values. </p><div class="fragment"><div class="line">{c++}</div><div class="line">for(auto&amp;&amp; i : filter(vec)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>filterfalse </h2>
<p>Similar to filter, but only prints values that are false under the predicate.</p>
<p>Prints values not greater than 4: <code>1 4 3 2 3 2 1</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; vec{1, 5, 4, 0, 6, 7, 3, 0, 2, 8, 3, 2, 1};</div><div class="line">for (auto&amp;&amp; i : filterfalse([] (int i) { return i &gt; 4; }, vec)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt;&#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>If no predicate is passed, the elements themselves are tested for truth.</p>
<p>Prints only zero values. </p><div class="fragment"><div class="line">{c++}</div><div class="line">for(auto&amp;&amp; i : filterfalse(vec)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --> <h2>unique_everseen </h2>
<p><em>Additional Requirements</em>: Underlying values must be copy-constructible.</p>
<p>This is a filter adaptor that only generates values that have never been seen before. For this to work your object must be specialized for <code>std::hash</code>.</p>
<p>Prints <code>1 2 3 4 5 6 7 8 9</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; v {1,2,3,4,3,2,1,5,6,7,7,8,9,8,9,6};</div><div class="line">for (auto&amp;&amp; i : unique_everseen(v)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39; &#39;;</div><div class="line">}</div></div><!-- fragment --><h2>unique_justseen </h2>
<p>Another filter adaptor that only omits consecutive duplicates.</p>
<p>Prints <code>1 2 3 4 3 2 1</code> Example Usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; v {1,1,1,2,2,3,3,3,4,3,2,1,1,1};</div><div class="line">for (auto&amp;&amp; i : unique_justseen(v)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39; &#39;;</div><div class="line">}</div></div><!-- fragment --><h2>takewhile </h2>
<p>Yields elements from an iterable until the first element that is false under the predicate is encountered.</p>
<p>Prints <code>1 2 3 4</code>. (5 is false under the predicate) </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; ivec{1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1};</div><div class="line">for (auto&amp;&amp; i : takewhile([] (int i) {return i &lt; 5;}, ivec)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>dropwhile </h2>
<p>Yields all elements after and including the first element that is true under the predicate.</p>
<p>Prints <code>5 6 7 1 2</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; ivec{1, 2, 3, 4, 5, 6, 7, 1, 2};</div><div class="line">for (auto&amp;&amp; i : dropwhile([] (int i) {return i &lt; 5;}, ivec)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>cycle </h2>
<p><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p>Repeatedly produces all values of an iterable. The loop will be infinite, so a <code>break</code> or other control flow structure is necessary to exit.</p>
<p>Prints <code>1 2 3</code> repeatedly until <code>some_condition</code> is true </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; vec{1, 2, 3};</div><div class="line">for (auto&amp;&amp; i : cycle(vec)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">    if (some_condition) {</div><div class="line">        break;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2>repeat </h2>
<p>Repeatedly produces a single argument forever, or a given number of times. <code>repeat</code> will bind a reference when passed an lvalue and move when given an rvalue. It will then yield a reference to the same item until completion.</p>
<p>The below prints <code>1</code> five times. </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto&amp;&amp; e : repeat(1, 5)) {</div><div class="line">    cout &lt;&lt; e &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>The below prints <code>2</code> forever </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto&amp;&amp; e : repeat(2)) {</div><div class="line">    cout &lt;&lt; e &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>count </h2>
<p>Effectively a <code>range</code> without a stopping point.<br />
 <code><a class="el" href="home_2lubuntu_2github_2ckpttncpp_2lib_2test_2src_2test__range_8cpp.html#af59ef6880260608617453e8e85b0a063">count()</a></code> with no arguments will start counting from 0 with a positive step of 1.<br />
 <code>count(i)</code> will start counting from <code>i</code> with a positive step of 1.<br />
 <code>count(i, st)</code> will start counting from <code>i</code> with a step of <code>st</code>.</p>
<p><em>Technical limitations</em>: Unlike Python which can use its long integer types when needed, <code><a class="el" href="home_2lubuntu_2github_2ckpttncpp_2lib_2test_2src_2test__range_8cpp.html#af59ef6880260608617453e8e85b0a063">count()</a></code> would eventually exceed the maximum possible value for its type (or minimum with a negative step). <code>count</code> is actually implemented as a <code>range</code> with the stopping point being the <code>std::numeric_limits&lt;T&gt;::max()</code> for the integral type (<code>long</code> by default)</p>
<p>The below will print <code>0 1 2</code> ... etc </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto&amp;&amp; i : count()) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>groupby </h2>
<p><em>Additional Requirements</em>: If the Input's iterator's <code>operator*()</code> returns a reference, the reference must remain valid after the iterator is incremented. Roughly equivalent to requiring the Input have a ForwardIterator.</p>
<p>Separate an iterable into groups sharing a common key. The following example creates a new group whenever a string of a different length is encountered. </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;string&gt; vec = {</div><div class="line">    &quot;hi&quot;, &quot;ab&quot;, &quot;ho&quot;,</div><div class="line">    &quot;abc&quot;, &quot;def&quot;,</div><div class="line">    &quot;abcde&quot;, &quot;efghi&quot;</div><div class="line">};</div><div class="line"></div><div class="line">for (auto&amp;&amp; gb : groupby(vec, [] (const string &amp;s) {return s.length(); })) {</div><div class="line">    cout &lt;&lt; &quot;key: &quot; &lt;&lt; gb.first &lt;&lt; &#39;\n&#39;;</div><div class="line">    cout &lt;&lt; &quot;content: &quot;;</div><div class="line">    for (auto&amp;&amp; s : gb.second) {</div><div class="line">        cout &lt;&lt; s &lt;&lt; &quot;  &quot;;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p> <em>Note</em>: Just like Python's <code>itertools.groupby</code>, this doesn't do any sorting. It just iterates through, making a new group each time there is a key change. Thus, if the group is unsorted, the same key may appear multiple times.</p>
<h2>starmap </h2>
<p>Takes a sequence of tuple-like objects (anything that works with <code>std::get</code>) and unpacks each object into individual arguments for each function call. The below example takes a <code>vector</code> of <code>pairs</code> of ints, and passes them to a function expecting two ints, with the elements of the <code>pair</code> being the first and second arguments to the function.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;pair&lt;int, int&gt;&gt; v = {{2, 3}, {5, 2}, {3, 4}}; // {base, exponent}</div><div class="line">for (auto&amp;&amp; i : starmap([](int b, int e){return pow(b, e);}, v)) {</div><div class="line">    // ...</div><div class="line">}</div></div><!-- fragment --><p><code>starmap</code> can also work over a tuple-like object of tuple-like objects even when the contained objects are different as long as the functor works with multiple types of calls. For example, a <code><a class="el" href="structCallable.html">Callable</a></code> struct with overloads for its <code>operator()</code> will work as long as all overloads have the same return type</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">struct Callable {</div><div class="line">    int operator()(int i) const;</div><div class="line">    int operator()(int i, char c) const;</div><div class="line">    int operator()(double d, int i, char c) const;</div><div class="line">};</div></div><!-- fragment --><p>This will work with a tuple of mixed types</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">auto t = make_tuple(</div><div class="line">        make_tuple(5), // first form</div><div class="line">        make_pair(3, &#39;c&#39;), // second</div><div class="line">        make_tuple(1.0, 1, &#39;1&#39;)); // third</div><div class="line">for (auto&amp;&amp; i : starmap(Callable{}, t)) {</div><div class="line">    // ...</div><div class="line">}</div></div><!-- fragment --><h2>accumulate </h2>
<p><em>Additional Requirements</em>: Type return from functor (with reference removed) must be assignable.</p>
<p>Differs from <code>std::accumulate</code> (which in my humble opinion should be named <code>std::reduce</code> or <code>std::foldl</code>). It is similar to a functional reduce where one can see all of the intermediate results. By default, it keeps a running sum. Prints: <code>1 3 6 10 15</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (auto&amp;&amp; i : accumulate(range(1, 6))) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p> A second, optional argument may provide an alternative binary function to compute results. The following example multiplies the numbers, rather than adding them. Prints: <code>1 2 6 24 120</code></p>
<div class="fragment"><div class="line">{c++}</div><div class="line">for (auto&amp;&amp; i : accumulate(range(1, 6), std::multiplies&lt;int&gt;{})) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>Note: The intermediate result type must support default construction and assignment.</p>
<h2>zip </h2>
<p>Takes an arbitrary number of ranges of different types and efficiently iterates over them in parallel (so an iterator to each container is incremented simultaneously). When you dereference an iterator to "zipped" range you get a tuple of the elements the iterators were holding.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">array&lt;int,4&gt; iseq{{1,2,3,4}};</div><div class="line">vector&lt;float&gt; fseq{1.2,1.4,12.3,4.5,9.9};</div><div class="line">vector&lt;string&gt; sseq{&quot;i&quot;,&quot;like&quot;,&quot;apples&quot;,&quot;a lot&quot;,&quot;dude&quot;};</div><div class="line">array&lt;double,5&gt; dseq{{1.2,1.2,1.2,1.2,1.2}};</div><div class="line"></div><div class="line">for (auto&amp;&amp; [i, f, s, d] : zip(iseq, fseq, sseq, dseq)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; f &lt;&lt; &#39; &#39; &lt;&lt; s &lt;&lt; &#39; &#39; &lt;&lt; d &lt;&lt; &#39;\n&#39;;</div><div class="line">    f = 2.2f; // modifies the underlying &#39;fseq&#39; sequence</div><div class="line">}</div></div><!-- fragment --><h2>zip_longest </h2>
<p>Terminates on the longest sequence instead of the shortest. Repeatedly yields a tuple of <code>boost::optional&lt;T&gt;</code>s where <code>T</code> is the type yielded by the sequences' respective iterators. Because of its boost dependency, <code>zip_longest</code> is not in <code><a class="el" href="itertools_8hpp.html">itertools.hpp</a></code> and must be included separately. The following loop prints either "Just &lt;item&gt;" or "Nothing" for each element in each tuple yielded.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; v1 = {0, 1, 2, 3};</div><div class="line">vector&lt;int&gt; v2 = {10, 11};</div><div class="line">for (auto&amp;&amp; [x, y] : zip_longest(v1, v2)) {</div><div class="line">    cout &lt;&lt; &#39;{&#39;;</div><div class="line">    if (x) {</div><div class="line">        cout &lt;&lt; &quot;Just &quot; &lt;&lt; *x;</div><div class="line">    } else {</div><div class="line">        cout &lt;&lt; &quot;Nothing&quot;;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; &quot;, &quot;;</div><div class="line">    if (y) {</div><div class="line">        cout &lt;&lt; &quot;Just &quot; &lt;&lt; *y;</div><div class="line">    } else {</div><div class="line">        cout &lt;&lt; &quot;Nothing&quot;;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; &quot;}\n&quot;;</div><div class="line">}</div></div><!-- fragment --><p>The output is: </p><div class="fragment"><div class="line">{Just 0, Just 10}</div><div class="line">{Just 1, Just 11}</div><div class="line">{Just 2, Nothing}</div><div class="line">{Just 3, Nothing}</div></div><!-- fragment --><h2>imap </h2>
<p>Takes a function and one or more iterables. The number of iterables must match the number of arguments to the function. Applies the function to each element (or elements) in the iterable(s). Terminates on the shortest sequence.</p>
<p>Prints the squares of the numbers in vec: <code>1 4 9 16 25</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; vec{1, 2, 3, 4, 5};</div><div class="line">for (auto&amp;&amp; i : imap([] (int x) {return x * x;}, vec)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>With more than one sequence, the below adds corresponding elements from each vector together, printing <code>11 23 35 47 59 71</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; vec1{1, 3, 5, 7, 9, 11};</div><div class="line">vector&lt;int&gt; vec2{10, 20, 30, 40, 50, 60};</div><div class="line">for (auto&amp;&amp; i : imap([] (int x, int y) { return x + y; }, vec1, vec2)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p><em>Note</em>: The name <code>imap</code> is chosen to prevent confusion/collision with <code>std::map</code>, and because it is more related to <code>itertools.imap</code> than the python builtin <code>map</code>.</p>
<h2>compress </h2>
<p>Yields only the values corresponding to true in the selectors iterable. Terminates on the shortest sequence.</p>
<p>Prints <code>2 6</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; ivec{1, 2, 3, 4, 5, 6};</div><div class="line">vector&lt;bool&gt; bvec{false, true, false, false, false, true};</div><div class="line">for (auto&amp;&amp; i : compress(ivec, bvec) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>sorted </h2>
<p><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p>Allows iteration over a sequence in sorted order. <code>sorted</code> does <b>not</b> produce a new sequence, copy elements, or modify the original sequence. It only provides a way to iterate over existing elements. <code>sorted</code> also takes an optional second <a href="http://en.cppreference.com/w/cpp/concept/Compare">comparator</a> argument. If not provided, defaults to <code>std::less</code>. <br />
 Iterables passed to sorted are required to have an iterator with an <code>operator*() const</code> member.</p>
<p>The below outputs <code>0 1 2 3 4</code>.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">unordered_set&lt;int&gt; nums{4, 0, 2, 1, 3};</div><div class="line">for (auto&amp;&amp; i : sorted(nums)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>chain </h2>
<p><em>Additional Requirements</em>: The underlying iterators of all containers' <code>operator*</code> must have the <em>exact</em> same type</p>
<p>This can chain any set of ranges together as long as their iterators dereference to the same type.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; empty{};</div><div class="line">vector&lt;int&gt; vec1{1,2,3,4,5,6};</div><div class="line">array&lt;int,4&gt; arr1{{7,8,9,10}};</div><div class="line"></div><div class="line">for (auto&amp;&amp; i : chain(empty,vec1,arr1)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>chain.from_iterable </h2>
<p>Similar to chain, but rather than taking a variadic number of iterables, it takes an iterable of iterables and chains the contained iterables together. A simple example is shown below using a vector of vectors to represent a 2d ragged array, and prints it in row-major order. </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;vector&lt;int&gt;&gt; matrix = {</div><div class="line">    {1, 2, 3},</div><div class="line">    {4, 5},</div><div class="line">    {6, 8, 9, 10, 11, 12}</div><div class="line">};</div><div class="line"></div><div class="line">for (auto&amp;&amp; i : chain.from_iterable(matrix)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>reversed </h2>
<p><em>Additional Requirements</em>: Input must be compatible with <code>std::rbegin()</code> and <code>std::rend()</code></p>
<p>Iterates over elements of a sequence in reverse order.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">for (auto&amp;&amp; i : reversed(a)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>slice </h2>
<p>Returns selected elements from a range, parameters are start, stop and step. the range returned is [start,stop) where you only take every step element</p>
<p>This outputs <code>0 3 6 9 12</code> </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; a{0,1,2,3,4,5,6,7,8,9,10,11,12,13};</div><div class="line">for (auto&amp;&amp; i : slice(a,0,15,3)) {</div><div class="line">    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>sliding_window </h2>
<p><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p>Takes a section from a range and increments the whole section. If the window size is larger than the length of the input, the <code>sliding_window</code> will yield nothing (begin == end).</p>
<p>Example: <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></p>
<p>take a section of size 4, output is: </p><div class="fragment"><div class="line">1 2 3 4</div><div class="line">2 3 4 5</div><div class="line">3 4 5 6</div><div class="line">4 5 6 7</div><div class="line">5 6 7 8</div><div class="line">6 7 8 9</div></div><!-- fragment --><p>Example Usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; v = {1,2,3,4,5,6,7,8,9};</div><div class="line">for (auto&amp;&amp; sec : sliding_window(v,4)) {</div><div class="line">    for (auto&amp;&amp; i : sec) {</div><div class="line">        cout &lt;&lt; i &lt;&lt; &#39; &#39;;</div><div class="line">        i.get() = 90;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --> <h2>chunked </h2>
<p>chunked will yield subsequent chunkes of an iterable in blocks of a specified size. The final chunk may be shorter than the rest if the chunk size given does not evenly divide the length of the iterable.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; v {1,2,3,4,5,6,7,8,9};</div><div class="line">for (auto&amp;&amp; sec : chunked(v,4)) {</div><div class="line">    for (auto&amp;&amp; i : sec) {</div><div class="line">        cout &lt;&lt; i &lt;&lt; &#39; &#39;;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>The above prints: </p><div class="fragment"><div class="line">1 2 3 4</div><div class="line">5 6 7 8</div><div class="line">9</div></div><!-- fragment --><h2>product </h2>
<p><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p>Generates the cartesian product of the given ranges put together.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; v1{1,2,3};</div><div class="line">vector&lt;int&gt; v2{7,8};</div><div class="line">vector&lt;string&gt; v3{&quot;the&quot;,&quot;cat&quot;};</div><div class="line">vector&lt;string&gt; v4{&quot;hi&quot;,&quot;what&#39;s&quot;,&quot;up&quot;,&quot;dude&quot;};</div><div class="line">for (auto&amp;&amp; [a, b, c, d] : product(v1,v2,v3,v4)) {</div><div class="line">    cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; &quot;, &quot; &lt;&lt; d &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><p>Product also accepts a "repeat" as a template argument. Currently this is the only way to do repeats. <b>If you are reading this and need <code>product(seq, 3)</code> instead of <code>product&lt;3&gt;(seq)</code> please open an issue</b>.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">std::string s = &quot;abc&quot;;</div><div class="line">// equivalent of product(s, s, s);</div><div class="line">for (auto&amp;&amp; t : product&lt;3&gt;(s)) {</div><div class="line">   // ...</div><div class="line">}</div></div><!-- fragment --><h2>combinations </h2>
<p><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p>Generates n length unique sequences of the input range.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; v = {1,2,3,4,5};</div><div class="line">for (auto&amp;&amp; i : combinations(v,3)) {</div><div class="line">    for (auto&amp;&amp; j : i ) cout &lt;&lt; j &lt;&lt; &quot; &quot;;</div><div class="line">    cout &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>combinations_with_replacement </h2>
<p><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p>Like combinations, but with replacement of each element. The below is printed by the loop that follows: </p><div class="fragment"><div class="line">{A, A}</div><div class="line">{A, B}</div><div class="line">{A, C}</div><div class="line">{B, B}</div><div class="line">{B, C}</div><div class="line">{C, C}</div></div><!-- fragment --> <div class="fragment"><div class="line">{c++}</div><div class="line">for (auto&amp;&amp; v : combinations_with_replacement(s, 2)) {</div><div class="line">    cout &lt;&lt; &#39;{&#39; &lt;&lt; v[0] &lt;&lt; &quot;, &quot; &lt;&lt; v[1] &lt;&lt; &quot;}\n&quot;;</div><div class="line">}</div></div><!-- fragment --><h2>permutations </h2>
<p><em>Additional Requirements</em>: Input must have a ForwardIterator. Iterator must have an <code>operator*() const</code>.</p>
<p>Generates all the permutations of a range using <code>std::next_permutation</code>.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; v = {1,2,3,4,5};</div><div class="line">for (auto&amp;&amp; vec : permutations(v)) {</div><div class="line">    for (auto&amp;&amp; i : vec) {</div><div class="line">        cout &lt;&lt; i &lt;&lt; &#39; &#39;;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>powerset </h2>
<p><em>Additional Requirements</em>: Input must have a ForwardIterator</p>
<p>Generates every possible subset of a set, runs in O(2^n).</p>
<p>Example usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">vector&lt;int&gt; vec {1,2,3,4,5,6,7,8,9};</div><div class="line">for (auto&amp;&amp; v : powerset(vec)) {</div><div class="line">    for (auto&amp;&amp; i : v) {</div><div class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; &#39;\n&#39;;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
