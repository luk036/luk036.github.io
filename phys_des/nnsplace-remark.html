<!doctype html>
<html>
  <head>
    <title>Fairness-Centric Global Placement Algorithm</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width"
    />
    <link rel="stylesheet" type="text/css" href="../katex/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/spaces.css" />
    <link rel="stylesheet" type="text/css" href="../css/slides.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-dark.css" />
    <link rel="stylesheet" type="text/css" href="../css/nord-light.css" />
    <link rel="stylesheet" type="text/css" href="../css/font-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/bg-nord.css" />
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>
  <body>
    <textarea id="source">
layout: true
class: typo, typo-selection

---

count: false
class: nord-dark, middle, center

# **Fairness-Centric Global Placement ğŸ¯**

@luk036 ğŸ‘¨â€ğŸ’»

2025-06-10 ğŸ“…

---

### Overview

*   **What is Global Placement?** Arranging circuit components (modules) on a grid. ğŸ§©
*   **Goal:** Optimize the placement to minimize wire lengths. ğŸ“‰
*   **Focus:** Minimizing the **worst wire length**. ğŸ¯
*   **Approach:** An iterative, fairness-centric method using Howard's algorithm and bipartite matching. ğŸ”„

---

### Global Placement ğŸ§©

*   **Placement:** The step in electronic circuit design where logical components (modules like logic gates, flip-flops, DSPs, SRAMs, I/O pads) are assigned physical locations on a grid. ğŸ“
*   **Netlist:** Input describing modules and their connections (wires). ğŸ“‹
*   **Grid:** The physical layout area where modules can be placed. ğŸŸ¦
*   **Why is it hard?** Many components, complex interconnections, physical constraints (grid size, dedicated blocks, I/O locations), and the need to minimize wire length for performance and routability. ğŸ¤¯

---

### Understanding Placement in Chip Design ğŸ–¥ï¸

- **Chip Design Parallels** ğŸ”„

    Like urban planners managing city development ğŸ™ï¸ğŸ‘·, placement engineers must organize components efficiently âš¡. Components must be positioned to minimize distance ğŸ“ while avoiding congestion ğŸš«ğŸš—.

    Global placement provides the "big picture" view ğŸ–¼ï¸â€”determining approximate positions before detailed placement finalizes exact locations ğŸ“, similar to zoning before construction ğŸ—ï¸ğŸ“‹.

- **Key Challenges** ğŸ—ï¸

    The fundamental challenge involves balancing competing objectives âš–ï¸: minimizing wire length ğŸ”Œ (reducing power âš¡ and delay â³) while addressing overlap constraints that are inherently non-convex ğŸ”„.

    This creates a mathematical complexity â— that traditional approaches struggle to solve efficiently ğŸ¢, especially as designs grow in size ğŸ“ˆ and complexity ğŸ§©.

---

### âš–ï¸ğŸ” Essential vs. Accidental Complexity ğŸ¤¹

- **Essential Complexity** ğŸ§¬

    Inherent challenges in the placement problem that cannot be avoided ğŸš«â€”like the need to balance wirelength minimization with area constraints ğŸ“.

- **Accidental Complexity** ğŸ­

    Complications introduced by our solution approachesâ€”like quadratic approximations that simplify mathematics â— but introduce new artifacts.

- **Finding Balance** âš–ï¸

    The art ğŸ¨ of placement algorithm design is recognizing which complexities are essential to the problem and which are artifacts of our solution methods.

Our traditional approaches often add accidental complexity when trying to simplify essential complexity ğŸ”„. A mindful approach ğŸ§˜ requires distinguishing between these two types of complexity to develop more elegant solutions ğŸ’.

---

### Analytical placement

- Approximations:
    - Quadratic approximation
        - QWL($e$) = $\omega_e \sum_{(i, j)\in e} [(x_i  -  x_j)^2 + (y_i  -  y_j)^2]$
        - can be solved efficiently by the conjugate gradient method.
    - Non-quadratic approximation
        - such as log-sum-exp technique:
            - $\max_{i\in e} x_i  - \min_{i\in e} x_i \approx
              \gamma (\log \sum_{i\in e} e^{x_i/\gamma}  + \log \sum_{i\in e} e^{-x_i/\gamma})$
- Gradients required are derived analytically
- Constraints:
    - fixed position constraints
    - density constraints

---

### ğŸ”„â“ The Quadratic Cost Model Paradox ğŸ¤¯

- **Mathematical Convenience** â•

    Chosen primarily for computational simplicity ğŸ§®

- **Implementation Complexity** ğŸ’»

    Requires advanced programming techniques ğŸ› ï¸

- **Modeling Inaccuracy** ğŸ“‰

    Fails to represent actual wire costs effectively ğŸ”Œ

The quadratic cost model persists in placement algorithms not because it accurately models physical reality ğŸŒ, but because it makes the mathematical problem tractable âœï¸. This creates a paradox ğŸ¤¹: we simplify one aspect of the problem while introducing new challenges ğŸ†•, such as the need for pseudo-nets and pseudo-IO points to manage the resulting artifacts ğŸ–¼ï¸.
Modern FPGA architectures present additional challenges as their actual wire costs follow concave rather than convex patterns ğŸ”„, further undermining the quadratic approximation's validity âŒ.

---

### Optimize x- and y-directions separately. Why?

![](R-C.jpeg)

---

![](download.jpeg)

---

### Half Perimeter wire-length Model, HPWL

- HPWL($e$) = xHPWL(e) + yHPWL(e)
  - xHPWL($e$) = $\max_{i\in e} x_i  - \min_{i\in e} x_i$
  - yHPWL($e$) = $\max_{i\in e} y_i  - \min_{i\in e} y_i$
- Underestimate when $n > 3$, where $n$ = the number of pins of a net.
- Convex but non-smooth.
- Some compensation factors (e.g. Rent's rule) has been used.

---

### ğŸ“ğŸ”Œ HPWL: Simplifying Wire Length Estimation âœ‚ï¸

- **Mathematical Properties** â—

    The HPWL model is piecewise linear ğŸ“ˆ, making it more accurate than quadratic approximations. However, it introduces non-differentiability at certain points âš ï¸, creating computational challenges for optimization algorithms ğŸ¤–.

- **Practical Implications** ğŸ› ï¸

    While HPWL provides a better approximation of actual routing costs ğŸ’°, it still focuses on total wirelength minimization rather than addressing the fundamental congestion issues that arise from uneven resource distribution.

Modern approaches often use log-sum-exp approximations to maintain the benefits of HPWL while regaining mathematical differentiability âœ¨, enabling more efficient optimization methods âš¡.

---

### Routability and Congestion Challenge ğŸš§

- **Identify the True Problem** ğŸ”

    The core issue isn't insufficient routing resources âŒ but their unequal distribution âš–ï¸. Some circuit areas receive abundant routing opportunities ğŸŒŸ while others face severe restrictions ğŸš«â€”similar to traffic jams ğŸš—ğŸ’¨ caused not by road shortage but by uneven utilization ğŸ”„.

- **Recognize Inherent Limitations** ğŸ§ 

    Simply minimizing total wirelength creates optimization blind spots ğŸ™ˆ, as the algorithm will sacrifice fairness to achieve global minimization ğŸŒ. This leads to predictable congestion in certain areas of the design ğŸ—ºï¸.

- **Shift Design Priorities** ğŸ”„

    In modern designs, especially FPGAs with fixed routing resources âš™ï¸, timing â±ï¸ and congestion concerns often outweigh total wirelength. Our algorithms need to reflect these shifted priorities âš–ï¸.

The Chinese proverb "ä¸æ‚£å¯¡è€Œæ‚£ä¸å‡" (We don't worry about scarcity, but about unfairness) perfectly captures this challengeâ€”the problem isn't insufficient resources but their unequal distribution âš–ï¸.

---

### âš–ï¸ğŸ”„ Min-Max Fairness: A New Paradigm ğŸŒŸ

- **Principle of Fair Allocation** âš–ï¸

    Max-min fairness aims to maximize the minimum resources allocated to each agent ğŸ¤, ensuring a baseline level of service while allowing for flexible allocation beyond that minimum ğŸ”„.

- **Telecommunications Origin** ğŸ“¡

    This principle has strong roots in network traffic management ğŸŒ, where it ensures fair bandwidth allocationâ€”a perfect parallel to routing resource allocation in chip design ğŸ›ï¸.

- **Application to Placement** ğŸ—ï¸

    In placement, this means minimizing the worst-case wirelength or delay âš ï¸ rather than the total, fundamentally changing our optimization approach to prioritize fairness over global minimization ğŸŒ.

---

### ğŸŒâš¡ Fairness-Centric Global Placement ğŸš€

- **Fairness-Centric Model** âš–ï¸

    Focuses on enforcing fairness rather than equality, which is mathematically more tractable â—

- **Minimizing Worst Case** âš ï¸

    Targets the maximum wirelength/delay rather than the sum total â•

- **Legalization Assisted** âš–ï¸

    Incorporates legalization constraints directly into the placement process ğŸ—ï¸

- **Computational Efficiency** âš¡

    Can eliminate floating-point arithmetic with linear cost models ğŸ“ˆ

---

Fairness-Centric placement represents a paradigm shift ğŸ”„, focusing on fair distribution of routing resources rather than absolute minimization. This approach naturally avoids the clustering effect seen in traditional methods ğŸ§©, leading to more predictable routing outcomes ğŸ¯ and fewer detours during global routing ğŸ›£ï¸.

---

### âš™ï¸ğŸ”„ Legalization-Assisted Placement ğŸ—ï¸

- **Integrated Approach** ğŸ¤

    Combines global and detailed placement phases ğŸ”„

- **Continuous Feedback** ğŸ”

    Legalization constraints inform global decisions ğŸŒ

- **Simplicity and Effectiveness** âœ¨

    Reduces algorithm complexity while improving results ğŸ“Š

Traditional placement flows separate global placement (determining approximate positions ğŸ“) from legalization (ensuring no overlaps âŒ). This separation often creates disconnect ğŸ”Œ, where global decisions become invalidated during legalization. Legalization-assisted placement integrates these phases ğŸ”„, using legalization constraints to guide global placement decisions ğŸ§­.

---

This approach not only simplifies the algorithm â– but also produces more predictable results ğŸ¯. By continuously ensuring that placement decisions remain legally viable âš–ï¸, we avoid the dramatic shifts that occur when legalization is applied as an afterthought ğŸ’­.

---

### Fairness-Centric Placement Goals ğŸ¯

*   **Primary Goal:** Minimize the **worst wire length**. ğŸ“‰
*   *Why worst wire length?* Long wires (high worst wire length) can cause timing violations and make routing impossible. Minimizing the *worst* case contributes to fairness, ensuring no single connection is excessively long. âš–ï¸
*   **Constraints:** Modules must not overlap, must respect grid boundaries and dedicated areas (like column 27 for DSP/SRAM). ğŸš§

---

### Algorithm Overview: Fairness-Centric Approach ğŸ”„

*   The algorithm is referred to as "fairness-centric" (NNS). âš–ï¸
*   It iteratively improves placement. ğŸ”„
*   Key steps:
    1.  Create a flow graph from the netlist. ğŸ“Š
    2.  Generate an initial random placement. ğŸ²
    3.  Repeatedly apply Howard's algorithm along X and Y axes.
    4.  Legalize the placement to fix overlaps and constraints. âš–ï¸
    5.  Assign I/O pads to grid edges. ğŸ“
    6.  Continue until satisfactory placement or max iterations reached. ğŸ”
*   Analogy: "Arranging puzzle pieces (circuit modules) on a board (the grid) in a way that minimizes the total length of strings (wires) connecting related pieces, while making sure all pieces fit within the board's boundaries." ğŸ§© (Note: The primary goal is minimizing the *worst* wire, not necessarily the total length in this specific implementation description, although minimizing worst often helps total).

---

### Data Structures & Libraries ğŸ“š

*   **Netlist:** Description of circuit components and connections. Handled by the `netlistx.netlist` module. Contains modules, nets, pads. ğŸ“‹
*   **Flow Graph:** Represents connections between modules, derived from the netlist. Can use `TinyDiGraph` or `nx.DiGraph` (NetworkX). Edges are added bidirectionally between connected modules. ğŸ“Š
*   **Placement Representation:** A 2D list (`place`) where `place` stores x-coordinates and `place` stores y-coordinates for each module. ğŸ“
*   **Counts/Limits:** Lists (`self.count`, `self.limit`) to track the number of modules in each row/column and the maximum allowed. Includes space for I/O rows/columns. ï¿½
*   **Grid Configuration:** Handled by `NnsConfig` (`self.cfg`), defines grid size (`cfg.grid`) and cost scaling factors (`cfg.delta`). âš™ï¸
*   **Physical Design Primitives:** Uses `physdes` library for geometric objects like `Interval`, `Point`, `Rect`. ğŸ“

---

### Initial Placement ğŸ²

*   A starting point is generated randomly. ğŸ°
*   Modules are assigned column and row indices within the grid boundaries. ğŸ“
*   A list of modules (`lst`) is shuffled, and then each module is assigned an (x, y) coordinate incrementally across rows. ğŸ”€
*   Counts for modules in each row/column are updated. ğŸ”¢
*   Special handling for column 27, which is assumed to be preserved for DSP or SRAM and skipped during this phase. âš ï¸
*   Assertions check against column 27 being used and limits being exceeded initially. âœ…

---

### Core Optimization: Howard's Algorithm ğŸ“ˆ

*   Applied along each axis (X then Y, or vice-versa). â†”ï¸
*   The `apply_howard` function uses `min_parametric` from `digraphx.min_parametric_q`. ğŸ”¢
*   This involves finding the minimum ratio in a directed graph. ğŸ“‰
*   Howard's algorithm is a minimum cycle ratio solver often used in combination with negative cycle finding. ğŸ”„
*   It iteratively adjusts distances/positions based on edge weights derived from costs. âš–ï¸
*   The cost for an edge (connection) along one axis depends on the positions of the connected modules along the *opposite* axis, scaled by `self.cfg.delta`. ğŸ“Š

---

### Cost Function & Worst Wirelength ğŸ“‰

*   **Cost Function:** Calculates the cost of a distance based on the axis.
    $$
    \text{cost}(\text{length}, \text{axis}) = \text{length} \times \text{self.cfg.delta}[\text{axis}]
    $$ ğŸ’°

*   `self.cfg.delta[axis]` are configuration parameters that scale costs differently for X and Y axes. âš–ï¸

*   **Worst Wirelength Calculation:** Finds the maximum cost among all connections in the graph based on the Manhattan distance between connected modules.

*   The algorithm aims to minimize `max(wirelength(u, v))` over all connected (u, v) pairs. ğŸ¯

---

### Placement Legalization âš–ï¸

*   Ensures modules do not overlap and respect grid constraints. ğŸš§
*   Uses **bipartite matching**. â†”ï¸
*   The `legalize` function constructs a bipartite graph. ğŸ“Š
*   One set of nodes in the bipartite graph represents the modules to be legalized (`lst`). ğŸ…°ï¸
*   The other set represents potential new positions for these modules, often based on their current positions shifted by a certain neighborhood. ğŸ…±ï¸
*   Edges connect modules to potential new positions, with weights representing the change in worst wirelength for that module if moved. âš–ï¸
*   `bipartite.minimum_weight_full_matching` is used to find an assignment of modules to new positions that minimizes the total change in worst wirelength within the neighborhood. ğŸ”
*   If no match is found, the neighborhood size is increased. ğŸ”
*   Positions and row/column counts (`self.count`) are updated based on the matching results. ğŸ”¢
*   `legalize_modules` applies this process to modules, grouping them into buckets based on their coordinate on the *opposite* axis. ğŸª£

---

### I/O Pad Assignment ğŸ“

*   I/O pads are assigned to the edges of the grid. ğŸ
*   The `io_assign` function orchestrates this. ğŸ¼
*   `choose_nearest_iopad` selects the nearest grid edge (0 or grid+1) for each I/O pad. ğŸ“
*   This choice is based on minimizing the *worst-case distance* to connected modules, considering both X and Y options and available space (`self.count`) along the edges. ğŸ“
*   After choosing edges, `legalize_iopad` potentially adjusts positions of pads already assigned to an edge using the `legalize` function (though the source comments suggest the `legalize` call within `legalize_iopad` operates on the *opposite* axis from the edge axis, which seems counter-intuitive - needs careful reading). ğŸ¤”
*   Grid edges for I/O: Row 0, Row `grid_y`+1, Column 0, Column `grid_x`+1. ğŸ“
*   I/O pads are treated differently from standard modules (`num_pads`). âš ï¸

---

### Iterative Optimization Loop ğŸ”„

*   The core optimization process is run iteratively. ğŸ”
*   The `optimize` function performs one full step. â–¶ï¸
*   Inside the loop:
    1.  Apply Howard's algorithm on X-axis. â†”ï¸
    2.  Legalize modules (possibly along Y-axis based on bucket logic?). âš–ï¸
    3.  Choose/assign I/O pads. ğŸ“
    4.  Apply Howard's algorithm on Y-axis. â†•ï¸
    5.  Legalize modules (possibly along X-axis?). âš–ï¸
    6.  Choose/assign I/O pads again. ğŸ“
*   The `run` function executes the `optimize` loop for `max_iters`. ğŸ”¢
*   The algorithm keeps track of the best placement found so far (lowest worst wirelength). ğŸ†
*   Stopping criteria mentioned: "until no further improvement is possible" or "a specified number of iterations", implemented by checking if the worst wirelength increased in an iteration. If it increased, the placement is reverted to the previous best. â¹ï¸

---

### Key Algorithms Summary ğŸ“š

*   **Howard's Algorithm:** Used within `min_parametric` to optimize positions along an axis by solving a minimum ratio problem. Based on finding negative cycles in a graph. ğŸ”„
*   **Parametric Minimum Cost Flow:** `digraphx.min_parametric` solves a specific network optimization problem parameterized by a ratio. Used to find the placement along an axis that satisfies constraints for a given 'radius' (related to wirelength). ğŸ“Š
*   **Negative Cycle Finder:** `digraphx.neg_cycle_q` (or similar, based on Howard/Bellman-Ford) detects cycles where the sum of edge weights is negative, used in minimum ratio or parametric problems. ğŸ”
*   **Bipartite Matching:** Used in `legalize` to reassign module positions based on finding a minimum weight match between modules and potential grid locations. Solved using NetworkX's `minimum_weight_full_matching`. â†”ï¸
*   **Geometric Primitives:** `physdes` library for handling points, intervals, and rectangles simplifies calculations like distances (`min_dist`), containment (`contains`), and bounding boxes (`hull_with`, `length`, `width`, `height`) for wirelength estimations. ğŸ“

---

### `digraphx` Usage Example ğŸ’»

*   The `apply_howard` function calls `min_parametric`. ğŸ“
*   `min_parametric` takes the flow graph (`self.gr`), an initial ratio (`Fraction(worst)`), functions to calculate edge weight (`calc_weight`) and zero cancellation (`zero_cancel`), the placement on the current axis (`place[axis]`), and an update check function (`update_ok`). ğŸ“‹
*   `calc_weight` uses the current beta (ratio) and edge cost to compute a weight. âš–ï¸
*   `zero_cancel` calculates the ratio for a cycle based on total cost and cycle length. ğŸ”„
*   `update_ok` checks if moving a module to a new position is valid (e.g., not outside grid, not exceeding row/column limits) before updating the internal counts (`self.count`). âœ…

---

### `netlistx` and `physdes` Usage ğŸ“š

*   `netlistx.Netlist`: Represents the input circuit netlist, providing access to modules, nets, and counts. Used during initialization to build the flow graph and in various calculations involving nets. ğŸ“‹
*   `physdes.Interval`: Represents a range. Used in `calc_total_hull_length` to compute the bounding box (hull) of net connections along an axis and its length. ğŸ“
*   `physdes.Point`: Represents a coordinate in 2D space. Used in commented-out `calc_total_hpwl` for calculating bounding boxes. ğŸ“
*   `physdes.Rect`: Represents an axis-aligned rectangle. Used in commented-out `calc_total_hpwl` for bounding boxes. ğŸŸ¦
*   These geometric objects and their methods like `hull_with` and `length` simplify physical design calculations. ğŸ§®

---

### Summary & Conclusion ğŸ“

*   The Fairness-Centric FPGA Placement Algorithm (NNS) aims to minimize the **worst wire length**. ğŸ¯
*   It uses an iterative process involving:
    *   Initial random placement. ğŸ²
    *   Applying Howard's algorithm along each axis for optimization. ğŸ“ˆ
    *   Legalizing placement using bipartite matching to resolve conflicts. âš–ï¸
    *   Assigning I/O pads to the periphery. ğŸ“
*   Leverages specific libraries: `netlistx` for netlist representation, `digraphx` for graph algorithms (parametric min-cost flow, negative cycles), and `physdes` for geometric calculations. ğŸ“š
*   The core optimization relies on `min_parametric`, which uses concepts from minimum ratio cycle problems and negative cycle finding. ğŸ”„
*   Legalization is handled efficiently using minimum weight bipartite matching. â†”ï¸
*   This approach provides a structured way to optimize FPGA placement with a focus on ensuring fairness by bounding the maximum wire length. âœ¨

---

### ğŸ”®ğŸš€ Future Directions ğŸŒŒ

- **Fairness-First Algorithms** âš–ï¸

    Prioritizing equitable resource distribution over absolute minimization â–

- **Integrated Flows** ğŸ”„

    Breaking down artificial separations between placement phases ğŸ§±

- **Design-Specific Metrics** ğŸ¯

    Tailoring placement objectives to actual design goals rather than generic metrics ğŸ“Š

The future of placement technology lies in recognizing that our traditional objectives don't always align with design goals ğŸ¯.
As we move forward ğŸš¶, placement algorithms will likely become more design-specific ğŸ¨, focusing on the metrics that matter most for each particular application rather than applying one-size-fits-all optimization approaches ğŸ‘•. The key insight remains ğŸ”‘: sometimes the most elegant solution comes not from solving the problem as defined, but from redefining the problem itself ğŸ’¡.

---

count: false
class: nord-dark, middle, center

# Q&A ğŸ¤
   </textarea>
    <script src="../js/remark.min.js"></script>
    <script src="../js/quasar.umd.min.js"></script>
    <script src="../js/mermaid.min.js"></script>
    <script src="../katex/katex.min.js" type="text/javascript"></script>
    <script
      src="../katex/contrib/auto-render.min.js"
      type="text/javascript"
    ></script>
    <script>
      renderMathInElement(document.getElementById("source"), {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      });
      var slideshow = remark.create({
        ratio: "4:3", // çª—å£æ¯”ä¾‹
        // å¯é€‰ï¼šarta, ascetic, dark, default, far, github, googlecode, idea,
        // ir-black, magula, monokai, rainbow, solarized-dark, solarized-light,
        // sunburst, tomorrow, tomorrow-night-blue, tomorrow-night-bright,
        // tomorrow-night, tomorrow-night-eighties, vs, zenburn.
        highlightStyle: "tomorrow-night-eighties",
        highlightLines: true,
        countIncrementalSlides: false, // å¢é‡å†…å®¹æ˜¯å¦ç®—ä¸€é¡µ
        // slideNumberFormat: "", // è‹¥å°†æ­¤å‚æ•°è®¾ç½®ä¸º ""ï¼Œå°†ä¸æ˜¾ç¤ºé¡µç 
        navigation: {
          scroll: false, // æ˜¯å¦å…è®¸ä½¿ç”¨é¼ æ ‡æ»šè½®ç¿»é¡µ
          touch: true, // ï¼ˆå¦‚æœæ˜¯è§¦æ‘¸å±ï¼‰æ˜¯å¦å…è®¸ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
          click: false, // æ˜¯å¦å…è®¸é¼ æ ‡ç‚¹å‡»å±å¹•å·¦è¾¹æˆ–å³è¾¹å‰åç¿»é¡µ
        },
      });

      // åˆå§‹åŒ– VUE
      for (var el of document.querySelectorAll(".vue")) {
        new Vue({
          el: el,
        });
      }

      // åˆå§‹åŒ–å¯ç‚¹å‡»é¢„è§ˆçš„å¡ç‰‡
      var preview_win_cards = document.querySelectorAll(".preview-win");
      for (var card of preview_win_cards) {
        ((clickedCard) => {
          clickedCard.addEventListener("click", (e) => {
            var img = clickedCard.querySelector("img");
            if (img) {
              window.open(img.src);
            }
          });
        })(card);
      }

      // èƒŒæ™¯è‰²å˜åŒ–å…¼å®¹ F11 å…¨å±
      function isFullScreen() {
        return (
          window.fullScreen ||
          (window.innerWidth == screen.width &&
            window.innerHeight == screen.height)
        );
      }

      window.addEventListener("resize", () => {
        if (isFullScreen()) {
          document.body.style["background-color"] = "#000";
        } else {
          document.body.style["background-color"] = "#d7d8d2";
        }
      });

      // åˆå§‹åŒ– mermaid
      mermaid.mermaidAPI.initialize({
        startOnLoad: false,
        theme: "forest",
        themeCSS:
          ".tick>text { font-size:26px; }  .taskTextOutsideRight,.taskTextOutsideLeft { font-size:20px; } .titleText {font-size:30px;} .sectionTitle {font-size:20px;}",
        gantt: {
          fontSize: 26,
          barHeight: 30,
          useMaxWidth: false,
        },
      });

      var mermaidCmps = document.querySelectorAll(".mermaid");
      for (var i = 0; i < mermaidCmps.length; i++) {
        var mermaidCmp = mermaidCmps[i];
        var insertSvg = function (svgCode, bindFunctions) {
          mermaidCmp.innerHTML = svgCode;
        };

        var graphDefinition = "";
        let pCmps = mermaidCmp.querySelectorAll("pre");
        for (var pCmp of pCmps) {
          graphDefinition += pCmp.textContent.replace(/\\n/g, "<br/>");
        }

        var graph = mermaid.mermaidAPI.render(
          "graphDiv" + i,
          graphDefinition,
          insertSvg,
        );
      }
    </script>
  </body>
</html>
