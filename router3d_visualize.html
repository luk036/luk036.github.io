<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Route Planning with Constraints and Keepouts</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
        .legend {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border: 1px solid #000;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">
            <h3>3D Route Planning</h3>
            <p>This visualization shows a 3D routing solution with constraints and keepouts.</p>
            <div class="legend">
                <div class="legend-color" style="background-color: #ff0000;"></div>
                <span>Source Node</span>
            </div>
            <div class="legend">
                <div class="legend-color" style="background-color: #0000ff;"></div>
                <span>Steiner Node</span>
            </div>
            <div class="legend">
                <div class="legend-color" style="background-color: #00ff00;"></div>
                <span>Terminal Node</span>
            </div>
            <div class="legend">
                <div class="legend-color" style="background-color: #ffc0cb;"></div>
                <span>Keepout Zone</span>
            </div>
            <p><strong>Wirelength:</strong> 7592.00 units</p>
            <p><strong>Total Nodes:</strong> 13</p>
            <p><strong>Terminals:</strong> 7</p>
            <p><strong>Steiner Points:</strong> 5</p>
        </div>
        <div id="controls">
            <button id="toggleKeepouts">Toggle Keepouts</button>
            <button id="toggleLabels">Toggle Labels</button>
            <button id="resetView">Reset View</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // Initialize Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 50, 50);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);
        
        // Define node types
        const NODE_TYPES = {
            SOURCE: { color: 0xff0000, size: 1.2 },
            STEINER: { color: 0x0000ff, size: 1.0 },
            TERMINAL: { color: 0x00ff00, size: 1.0 }
        };
        
        // Define connection types
        const CONNECTION_TYPES = {
            DIRECT: { color: 0x00ff00, width: 0.5 },
            ROUTED: { color: 0xffa500, width: 0.3 },
            CONSTRAINT: { color: 0xff0000, width: 0.3 },
            ALTERNATE: { color: 0x0000ff, width: 0.3 }
        };
        
        // Define keepout zones
        const keepouts = [
            { 
                position: { x: 600, y: 0, z: 0 }, 
                size: { x: 300, y: 10, z: 500 },
                visible: true
            },
            { 
                position: { x: -500, y: 0, z: -400 }, 
                size: { x: 300, y: 10, z: 300 },
                visible: true
            }
        ];
        
        // Define nodes based on the SVG data
        const nodes = [
            { id: 'source', type: NODE_TYPES.SOURCE, position: {x: -973, y: 0, z: 728} },
            { id: 'terminal_1', type: NODE_TYPES.TERMINAL, position: {x: -595, y: 2, z: 344} },
            { id: 'terminal_2', type: NODE_TYPES.TERMINAL, position: {x: 377, y: 2, z: 216} },
            { id: 'steiner_1', type: NODE_TYPES.STEINER, position: {x: -595, y: 0, z: 344} },
            { id: 'terminal_3', type: NODE_TYPES.TERMINAL, position: {x: -352, y: 0, z: -808} },
            { id: 'steiner_2', type: NODE_TYPES.STEINER, position: {x: 134, y: 2, z: 216} },
            { id: 'terminal_4', type: NODE_TYPES.TERMINAL, position: {x: 134, y: 4, z: -168} },
            { id: 'terminal_5', type: NODE_TYPES.TERMINAL, position: {x: 863, y: 6, z: 856} },
            { id: 'steiner_3', type: NODE_TYPES.STEINER, position: {x: -352, y: 0, z: -680} },
            { id: 'terminal_6', type: NODE_TYPES.TERMINAL, position: {x: 620, y: 0, z: -680} },
            { id: 'terminal_7', type: NODE_TYPES.TERMINAL, position: {x: 1106, y: 4, z: -296} },
        ];
        
        // Define connections based on the SVG data
        const connections = [
            { from: 'source', to: 'steiner_1', type: CONNECTION_TYPES.ROUTED },
            { from: 'steiner_1', to: 'terminal_1', type: CONNECTION_TYPES.ROUTED },
            { from: 'steiner_1', to: 'steiner_3', type: CONNECTION_TYPES.ROUTED },
            { from: 'terminal_1', to: 'steiner_2', type: CONNECTION_TYPES.ROUTED },
            { from: 'steiner_2', to: 'terminal_2', type: CONNECTION_TYPES.ROUTED },
            { from: 'steiner_2', to: 'terminal_4', type: CONNECTION_TYPES.ROUTED },
            { from: 'terminal_2', to: 'terminal_5', type: CONNECTION_TYPES.ROUTED },
            { from: 'terminal_4', to: 'terminal_7', type: CONNECTION_TYPES.ROUTED },
            { from: 'steiner_3', to: 'terminal_3', type: CONNECTION_TYPES.ROUTED },
            { from: 'steiner_3', to: 'terminal_6', type: CONNECTION_TYPES.ROUTED },
        ];
        
        // Create a lookup for nodes by ID
        const nodeMap = {};
        nodes.forEach(node => {
            nodeMap[node.id] = node;
        });
        
        // Scale factor to normalize coordinates for 3D visualization
        const scaleFactor = 0.01;
        
        // Create and add nodes to the scene
        const nodeObjects = [];
        nodes.forEach(node => {
            const geometry = new THREE.SphereGeometry(node.type.size, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: node.type.color });
            const sphere = new THREE.Mesh(geometry, material);
            
            // Scale and position the node
            sphere.position.set(
                node.position.x * scaleFactor,
                node.position.y,
                node.position.z * scaleFactor
            );
            
            // Store reference to the node
            sphere.userData = { nodeId: node.id, nodeType: node.type };
            nodeObjects.push(sphere);
            scene.add(sphere);
            
            // Add label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            context.fillStyle = '#000000';
            context.font = '24px Arial';
            context.textAlign = 'center';
            context.fillText(node.id, 64, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.set(
                node.position.x * scaleFactor,
                node.position.y + 2,
                node.position.z * scaleFactor
            );
            label.scale.set(4, 2, 1);
            label.userData = { nodeId: node.id };
            scene.add(label);
        });
        
        // Create and add connections to the scene
        const connectionObjects = [];
        connections.forEach(connection => {
            const fromNode = nodeMap[connection.from];
            const toNode = nodeMap[connection.to];
            
            if (fromNode && toNode) {
                // Create a tube geometry for the connection
                const points = [];
                points.push(new THREE.Vector3(
                    fromNode.position.x * scaleFactor,
                    fromNode.position.y,
                    fromNode.position.z * scaleFactor
                ));
                
                // For self-connections, create a loop
                if (connection.from === connection.to) {
                    points.push(new THREE.Vector3(
                        fromNode.position.x * scaleFactor + 2,
                        fromNode.position.y + 3,
                        fromNode.position.z * scaleFactor
                    ));
                    points.push(new THREE.Vector3(
                        fromNode.position.x * scaleFactor,
                        fromNode.position.y + 3,
                        fromNode.position.z * scaleFactor + 2
                    ));
                    points.push(new THREE.Vector3(
                        fromNode.position.x * scaleFactor - 2,
                        fromNode.position.y + 3,
                        fromNode.position.z * scaleFactor
                    ));
                }
                
                points.push(new THREE.Vector3(
                    toNode.position.x * scaleFactor,
                    toNode.position.y,
                    toNode.position.z * scaleFactor
                ));
                
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, 20, connection.type.width, 8, false);
                const material = new THREE.MeshPhongMaterial({ color: connection.type.color });
                const tube = new THREE.Mesh(geometry, material);
                
                connectionObjects.push(tube);
                scene.add(tube);
            }
        });
        
        // Create and add keepout zones to the scene
        const keepoutObjects = [];
        keepouts.forEach(keepout => {
            const geometry = new THREE.BoxGeometry(
                keepout.size.x * scaleFactor,
                keepout.size.y,
                keepout.size.z * scaleFactor
            );
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xffc0cb,
                transparent: true,
                opacity: 0.5
            });
            const box = new THREE.Mesh(geometry, material);
            box.position.set(
                keepout.position.x * scaleFactor,
                keepout.position.y,
                keepout.position.z * scaleFactor
            );
            box.userData = { keepoutId: keepoutObjects.length };
            keepoutObjects.push(box);
            scene.add(box);
        });
        
        // Add a grid to help with orientation
        const gridHelper = new THREE.GridHelper(30, 30, 0x444444, 0x888888);
        scene.add(gridHelper);
        
        // Add axes helper
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Control handlers
        document.getElementById('toggleKeepouts').addEventListener('click', () => {
            keepoutObjects.forEach(keepout => {
                keepout.visible = !keepout.visible;
            });
        });
        
        document.getElementById('toggleLabels').addEventListener('click', () => {
            scene.children.forEach(child => {
                if (child.type === 'Sprite') {
                    child.visible = !child.visible;
                }
            });
        });
        
        document.getElementById('resetView').addEventListener('click', () => {
            camera.position.set(50, 50, 50);
            controls.reset();
        });
    </script>
</body>
</html>